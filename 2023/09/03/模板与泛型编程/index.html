<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/myblog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/myblog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/myblog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/myblog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/myblog/css/main.css">


<link rel="stylesheet" href="/myblog/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/myblog/lib/pace/pace-theme-bounce.min.css">
  <script src="/myblog/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wujx99.github.io","root":"/myblog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="OOP能处理运行前类型未知的情况，而泛型编程中在编译期就能获知类型了。 定义模板 函数模板 1234567template &lt;typename T&gt;int compare(const T &amp;v1, const T &amp;v2)&amp;#123; 	if (v1 &lt; v2) return -1;  	if (v2 &lt; v1) return 1;  	return">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp模板与泛型编程">
<meta property="og:url" content="https://wujx99.github.io/myblog/2023/09/03/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="blogs&amp;record">
<meta property="og:description" content="OOP能处理运行前类型未知的情况，而泛型编程中在编译期就能获知类型了。 定义模板 函数模板 1234567template &lt;typename T&gt;int compare(const T &amp;v1, const T &amp;v2)&amp;#123; 	if (v1 &lt; v2) return -1;  	if (v2 &lt; v1) return 1;  	return">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-03T14:56:25.000Z">
<meta property="article:modified_time" content="2023-10-28T01:53:50.366Z">
<meta property="article:author" content="jxWu">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="cpp primer">
<meta property="article:tag" content="book">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wujx99.github.io/myblog/2023/09/03/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>cpp模板与泛型编程 | blogs&record</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/myblog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blogs&record</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/myblog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/myblog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/myblog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/myblog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/myblog/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/myblog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wujx99.github.io/myblog/2023/09/03/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/myblog/uploads/myimage.jpg">
      <meta itemprop="name" content="jxWu">
      <meta itemprop="description" content="record and up">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blogs&record">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cpp模板与泛型编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-03 22:56:25" itemprop="dateCreated datePublished" datetime="2023-09-03T22:56:25+08:00">2023-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-28 09:53:50" itemprop="dateModified" datetime="2023-10-28T09:53:50+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/myblog/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/myblog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>OOP能处理运行前类型未知的情况，而泛型编程中在编译期就能获知类型了。</p>
<h1 id="定义模板">定义模板</h1>
<h2 id="函数模板">函数模板</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"> 	<span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实例化函数模板</strong>
当我们使用函数的时候，编译器会根据传入的参数推断出模板实参。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl; <span class="comment">// T is int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>模板类型参数</strong></p>
<p><strong>非类型模板参数</strong>
非类型模板参数必须传递为常量表达式（这样才能实例化）。如下面的处理字符串字面常量的用法（我们不能拷贝数组，故而传递引用）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们如下的使用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给我耳目一新的感觉。</p>
</blockquote>
<p><strong>inline和constexpr的函数模板</strong>
inline和constexpr必须放在模板参数列表后面。</p>
<p><strong>编写类型无关的代码</strong> 两个重要的<strong>原则</strong> -
模板中的函数参数是<code>const</code>的引用。 -
函数体中的条件判断仅仅使用&lt;比较运算。</p>
<p>下面是一个更加类型无关的<code>compare</code>版本，可以<strong>处理指针</strong>（用到了函数对象）！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version of compare that will be correct even if used on pointers; see § 14.8.2 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (<span class="built_in">less</span>&lt;T&gt;()(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"> 	<span class="keyword">if</span> (<span class="built_in">less</span>&lt;T&gt;()(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模板编译</strong>
遇到模板定义的时候并不生成代码，使用的时候才会生成代码，这影响了我们如何组织代码和错误检测。</p>
<p>基于： - 调用函数的时候编译器只需要知道函数声明。 -
使用类类型对象的时候只需要知道类的定义。</p>
<p>我们<strong>才可以</strong>把类的定义和函数声明放在头文件里。函数和类成员函数的定义放在源文件。</p>
<p>模板不同，为了生成一个实例化的版本，必须知道定义。</p>
<blockquote>
<p>模板包含两种名字：1包含模板参数的名字；2依赖模板参数的名字。</p>
</blockquote>
<p><strong>大多数编译错误在实例化期间报告</strong>
编译器在三个阶段报告错误。 - 编译模板本身。 - 编译器遇到模板使用。 -
模板实例化时。只有这个阶段才能发现类型相关的错误，依赖于编译器如何管理实例化，可能在链接的时候才报告。</p>
<p>如下面，在示例化的时候才发现<code>Sales_data</code>没有定义<code>&lt;</code>。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data1, data2;</span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(data1, data2) &lt;&lt; endl; <span class="comment">// error: no &lt; on Sales_data</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong> 1. 模板定义的时候，模板参数列表不能为空 2.
非类型模板参数必须传递为常量表达式。绑定到引用或指针非类型参数的实参必须具有<strong>静态</strong>的生存期（编译期可以确定，不能是栈或堆里）。</p>
<h2 id="类模板">类模板</h2>
<p>与函数模板不同，编译器不能为类模板推断模板参数类型。我们必须在<code>&lt; &gt;</code>中提供
额外信息。</p>
<p><strong>定义类模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="keyword">typedef</span> T value_type; </span><br><span class="line"> 	<span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"> 	<span class="comment">// constructors</span></span><br><span class="line"> 	<span class="built_in">Blob</span>(); </span><br><span class="line"> 	<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);   <span class="comment">//可以通过&#123;&#125;初始化。</span></span><br><span class="line"> 	<span class="comment">// number of elements in the Blob</span></span><br><span class="line"> 	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125; </span><br><span class="line"> 	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line"> 	<span class="comment">// add and remove elements</span></span><br><span class="line"> 	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;t)</span> </span>&#123;data-&gt;<span class="built_in">push_back</span>(t);&#125;</span><br><span class="line"> 	<span class="comment">// move version; see § 13.6.3 (p. 548)</span></span><br><span class="line"> 	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t)); &#125; </span><br><span class="line"> 	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"> 	<span class="comment">// element access</span></span><br><span class="line"> 	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"> 	T&amp; <span class="keyword">operator</span>[](size_type i); <span class="comment">// defined in § 14.5 </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 	std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line"> 	<span class="comment">// throws msg if data[i] isn&#x27;t valid</span></span><br><span class="line"> 	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>实例化类模板</strong>
一个类模板的每个实例都会形成一个独立的类。</p>
<p><strong>在模板作用域引用模板类型</strong>
要记住类模板的名字<strong>不是一个类型名</strong>。</p>
<p>实例化<code>Blob&lt;int&gt;</code>,
<code>data</code>会变成<code>shared_ptr&lt;vector&lt;int&gt;&gt;</code>。</p>
<p><strong>类模板的成员函数</strong>
成员函数既可以定义在外部，也可以定义在内部（隐式声明为inline）。
类内定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret-type StrBlob::member-<span class="built_in">name</span>(parm-list)</span><br></pre></td></tr></table></figure>
<p>在类外定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member-<span class="built_in">name</span>(parm-list)</span><br></pre></td></tr></table></figure>
<p>我们定义<code>Blob</code>的成员（类外）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string &amp;msg)</span><br><span class="line"><span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>()) </span><br><span class="line"> 		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty Blob&quot;</span>); </span><br><span class="line"> 	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="comment">// if i is too big, check will throw, preventing access to a nonexistent element</span></span><br><span class="line"> 	<span class="built_in">check</span>(i, <span class="string">&quot;subscript out of range&quot;</span>); </span><br><span class="line"> 	<span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty Blob&quot;</span>); </span><br><span class="line"> 	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(): <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;()) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用列表初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il):</span><br><span class="line"> 	<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>类模板成员函数的实例化</strong>
成员函数未被使用也不会实例化！</p>
<p><strong>类代码内简化模板类名的使用</strong>
在类模板自己的作用域使用模板不通过实参（在指针类会用到）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BlobPtr throws an exception on attempts to access a nonexistent element</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="built_in">BlobPtr</span>(): <span class="built_in">curr</span>(<span class="number">0</span>) &#123; &#125; </span><br><span class="line"> 	<span class="built_in">BlobPtr</span>(Blob&lt;T&gt; &amp;a, <span class="type">size_t</span> sz = <span class="number">0</span>): <span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz) &#123; &#125; </span><br><span class="line"> 	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> </span><br><span class="line"> 	&#123; 	<span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line"> 		<span class="keyword">return</span> (*p)[curr]; <span class="comment">// (*p) is the vector to which this object points</span></span><br><span class="line"> &#125;</span><br><span class="line"> 	<span class="comment">// increment and decrement</span></span><br><span class="line"> 	BlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// prefix operators</span></span><br><span class="line"> 	BlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 	<span class="comment">// check returns a shared_ptr to the vector if the check succeeds</span></span><br><span class="line"> 	std::shared_ptr&lt;std::vector&lt;T&gt;&gt; <span class="built_in">check</span>(std::<span class="type">size_t</span>, <span class="type">const</span> std::string&amp;) <span class="type">const</span>;</span><br><span class="line"> 	<span class="comment">// store a weak_ptr, which means the underlying vector might be destroyed</span></span><br><span class="line"> 	std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;</span><br><span class="line"> 	std::<span class="type">size_t</span> curr; <span class="comment">// current position within the array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意上面<code>operator++</code>和<code>operator++</code>的返回类型可以不是<code>BlobPtr&lt;T&gt;&amp;</code>。</p>
<p><strong>类模板外使用类模板名</strong>
在类模板外定义其成员的时候，记住我们并不再类的作用域中，直到遇到类名才进入类作用域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// postfix: increment/decrement the object but return the unchanged value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="comment">// no check needed here; the call to prefix increment will do the check</span></span><br><span class="line"> 	BlobPtr ret = *<span class="keyword">this</span>; 	<span class="comment">// save the current value</span></span><br><span class="line"> 	++*<span class="keyword">this</span>; 				<span class="comment">// advance one element; prefix ++ checks the increment</span></span><br><span class="line"> 	<span class="keyword">return</span> ret; 			<span class="comment">// return the saved state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回类型<strong>不在</strong>类模板作用域内，使用<code>BlobPtr&lt;T&gt;</code>,<code>ret</code>（在作用域内）只使用<code>BlobPtr</code>就行。</p>
<p><strong>类模板和友元</strong></p>
<p>类和友元各自是否时模板时相互无关的。 -
类模板包含非模板的友元，友元可以访问所有模板实例！ -
类模板包含模板的友元，可以有选择的授权。</p>
<p>比较常见的是一对一模板<strong>实例</strong>的友好关系。如<code>Blob</code>和<code>BlobPtr</code>的实例一对一的友好关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为下面一对一友元提供的前置声明</span></span><br><span class="line"><span class="comment">// forward declarations needed for friend declarations in Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>; <span class="comment">// needed for parameters in operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"> 	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类内传递T来实现一对一的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line"> 	<span class="comment">// each instantiation of Blob grants access to the version of</span></span><br><span class="line"> 	<span class="comment">// BlobPtr and the equality operator instantiated with the same type</span></span><br><span class="line"> 	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BlobPtr</span>&lt;T&gt;; </span><br><span class="line"> 	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==&lt;T&gt; </span><br><span class="line"> 		(<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"> 	<span class="comment">// other members as in § 12.1.1 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没什么特别的，也就是<code>Blob</code>类内传递了同样的形参T来实现。进而实例化不同的友元类型。</p>
</blockquote>
<p>如下的声明就会建立不同的友元关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="type">char</span>&gt; ca; <span class="comment">// BlobPtr&lt;char&gt; and operator==&lt;char&gt; are friends</span></span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; ia; <span class="comment">// BlobPtr&lt;int&gt; and operator==&lt;int&gt; are friends</span></span><br></pre></td></tr></table></figure>
<p>也可以建立<strong>更加灵活</strong>的友好关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forward declaration necessary to befriend a specific instantiation of a template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Pal</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; <span class="comment">// C is an ordinary, nontemplate class</span></span><br><span class="line"> 	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>&lt;C&gt;; <span class="comment">// Pal instantiated with class C is a friend to C</span></span><br><span class="line"> 	<span class="comment">// all instances of Pal2 are friends to C;</span></span><br><span class="line"> 	<span class="comment">// no forward declaration required when we befriend all instantiations</span></span><br><span class="line"> 	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">C2</span> &#123; <span class="comment">// C2 is itself a class template</span></span><br><span class="line"> 	<span class="comment">// each instantiation of C2 has the same instance of Pal as a friend</span></span><br><span class="line"> 	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>&lt;T&gt;; <span class="comment">// a template declaration for Pal must be in scope</span></span><br><span class="line"> 	<span class="comment">// all instances of Pal2 are friends of each instance of C2, prior declaration needed</span></span><br><span class="line"> 	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal2</span>;</span><br><span class="line"> 	<span class="comment">// Pal3 is a nontemplate class that is a friend of every instance of C2</span></span><br><span class="line"> 	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal3</span>; <span class="comment">// prior declaration for Pal3 not needed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有的实例都是友元就<strong>不需要</strong>前置声明！</p>
</blockquote>
<p>也可以把<strong>自己的类型参数</strong>成为友元</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> Type; <span class="comment">// grants access to the type used to instantiate Bar</span></span><br><span class="line"> 	<span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内置类型的友好关系也是允许的，以便我们能够<strong>统一</strong>的实例化不同的类型。</p>
</blockquote>
<p><strong>模板类型别名</strong>
要注意模板不是类型！使用的是typedef，所以如下使用别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;string&gt; StrBlob;</span><br><span class="line"><span class="comment">//下面是错误的</span></span><br><span class="line"><span class="keyword">typedef</span> Blob&lt;T&gt; StrBlob;</span><br></pre></td></tr></table></figure>
<p>新标准允许下面的别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">// authors is a pair&lt;string, string&gt;</span></span><br><span class="line"><span class="comment">//如下使用</span></span><br><span class="line">twin&lt;<span class="type">int</span>&gt; win_loss; <span class="comment">// win_loss is a pair&lt;int, int&gt;</span></span><br><span class="line">twin&lt;<span class="type">double</span>&gt; area; <span class="comment">// area is a pair&lt;double, double&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//固定部分类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="type">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;string&gt; books; <span class="comment">// books is a pair&lt;string, unsigned&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>类模板的static成员</strong>
初始化类模板的static成员<code>ctr</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>; <span class="comment">// define and initialize ctr</span></span><br></pre></td></tr></table></figure>
使用static成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="type">int</span>&gt; fi; 					<span class="comment">// instantiates Foo&lt;int&gt; class</span></span><br><span class="line"> 								<span class="comment">// and the static data member ctr</span></span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">count</span>(); 	<span class="comment">// instantiates Foo&lt;int&gt;::count</span></span><br><span class="line">ct = fi.<span class="built_in">count</span>(); 				<span class="comment">// uses Foo&lt;int&gt;::count</span></span><br><span class="line">ct = Foo::<span class="built_in">count</span>(); 				<span class="comment">// error: which template instantiation?</span></span><br></pre></td></tr></table></figure>
<h2 id="模板参数">模板参数</h2>
<p>类似于函数参数，模板参数没有任何的含义。</p>
<p><strong>模板参数与作用域</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	A tmp = a;  <span class="comment">// A不是double</span></span><br><span class="line"> 	<span class="type">double</span> B;   <span class="comment">// error: 不能重定义模板参数B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>模板声明</strong>
模板声明必须包含模板参数，声明和定义的模板参数不必相同。</p>
<blockquote>
<p>一个文件的所需要的所有模板声明通常放在文件开始的位置，在16.3节解释。</p>
</blockquote>
<p><strong>使用类的类型成员</strong>
我们使用<code>::</code>来<strong>访问</strong>static成员和类型成员（如<code>string::size_type</code>)。但是对于模板代码就<strong>存在困难</strong>。</p>
<p>例如遇到了<code>T::mem</code>的代码，只有实例化了才知道<code>mem</code>是类型还是static数据成员。c++默认是static，如果是类型的话就要用<code>typename</code>指定（不能用class）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//用typename指定访问的是类型而不是static</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (!c.<span class="built_in">empty</span>()) </span><br><span class="line"> 		<span class="keyword">return</span> c.<span class="built_in">back</span>(); </span><br><span class="line"> 	<span class="keyword">else</span> </span><br><span class="line"> 		<span class="keyword">return</span> <span class="keyword">typename</span> T::<span class="built_in">value_type</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认模板实参</strong> 可以为类和函数模板提供默认实参</p>
<p>重新compare的代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare has a default template argument, less&lt;T&gt;</span></span><br><span class="line"><span class="comment">// and a default function argument, F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2, F f = <span class="built_in">F</span>())</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (<span class="built_in">f</span>(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"> 	<span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如下使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> i = <span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">42</span>); <span class="comment">// uses less; i is -1</span></span><br><span class="line"><span class="comment">// result depends on the isbns in item1 and item2</span></span><br><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(cin)</span>, <span class="title">item2</span><span class="params">(cin)</span></span>;</span><br><span class="line"><span class="type">bool</span> j = <span class="built_in">compare</span>(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>
<p><strong>模板默认实参与类模板</strong>
<strong>任何</strong>时候使用类模板都要带上<code>&lt; &gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">int</span>&gt; <span class="keyword">class</span> Numbers &#123; <span class="comment">// by default T is int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="built_in">Numbers</span>(T v = <span class="number">0</span>): <span class="built_in">val</span>(v) &#123; &#125;</span><br><span class="line"> 	<span class="comment">// various operations on numbers</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="type">long</span> <span class="type">double</span>&gt; lots_of_precision;</span><br><span class="line"><span class="comment">//使用默认的参数</span></span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// empty &lt;&gt; says we want the default type</span></span><br></pre></td></tr></table></figure>
<h2 id="成员模板">成员模板</h2>
<p>类（普通类或者类模板）可以包含本身是模板的成员函数。</p>
<p><strong>普通类的成员模板</strong>
我们定义一个类似<code>unique_ptr</code>所使用的默认删除器类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function-object class that calls delete on a given pointer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DebugDelete</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="built_in">DebugDelete</span>(std::ostream &amp;s = std::cerr): <span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line"> 	<span class="comment">// as with any function template, the type of T is deduced by the compiler</span></span><br><span class="line"> 	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"> 	</span>&#123; </span><br><span class="line"> 		os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std::endl; </span><br><span class="line"> 		<span class="keyword">delete</span> p;</span><br><span class="line"> 	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 	std::ostream &amp;os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如下的使用和传递我们自定义的删除器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>* p = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">DebugDelete d; <span class="comment">// an object that can act like a delete expression</span></span><br><span class="line"><span class="built_in">d</span>(p); <span class="comment">// calls DebugDelete::operator()(double*), which deletes p</span></span><br><span class="line"><span class="type">int</span>* ip = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// calls operator()(int*) on a temporary DebugDelete object</span></span><br><span class="line"><span class="built_in">DebugDelete</span>()(ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroying the the object to which p points</span></span><br><span class="line"><span class="comment">// 实例化 DebugDelete::operator()&lt;int&gt;(int *)</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>, DebugDelete&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, DebugDelete())</span></span>;</span><br><span class="line"><span class="comment">// destroying the the object to which sp points</span></span><br><span class="line"><span class="comment">// 实例化 DebugDelete::operator()&lt;string&gt;(string*)</span></span><br><span class="line"><span class="function">unique_ptr&lt;string, DebugDelete&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> string, DebugDelete())</span></span>;</span><br></pre></td></tr></table></figure>
<strong>类模板的成员模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span> &#123; </span><br><span class="line">	<span class="comment">//定义的使用迭代器的构造器</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="built_in">Blob</span>(It b, It e);</span><br><span class="line"> 	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在模板类<strong>外</strong>定义成员模板的时候要提供两组类型参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="comment">// 成员模板的类型参数</span></span><br><span class="line"> 	Blob&lt;T&gt;::<span class="built_in">Blob</span>(It b, It e): </span><br><span class="line"> 		<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实例化与成员模板</strong>
为了实例化成员模板<strong>也</strong>需要两组实参（函数实参是推断出来的）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">long</span>&gt; vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Blob&lt;<span class="type">int</span>&gt; <span class="title">a1</span><span class="params">(begin(ia), end(ia))</span></span>;<span class="comment">//begin，end是标准库的函数把</span></span><br><span class="line"><span class="function">Blob&lt;<span class="type">int</span>&gt; <span class="title">a2</span><span class="params">(vi.begin(), vi.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 1. 成员模板不能是虚函数。</p>
<h2 id="控制实例化">控制实例化</h2>
<p>模板使用的时候才会实例化，这说明相同的实例可能出现在多个对象文件里！为了避免这种浪费，就提出了显式实例化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// instantiation declaration</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">// instantiation definition</span></span><br></pre></td></tr></table></figure>
<p>如下的使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化声明和定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;; <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<p>下面是下个<strong>整体的</strong>例子</p>
<figure class="highlight cpp"><figcaption><span>Application.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// these template types must be instantiated elsewhere in the program</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;string&gt; sa1, sa2; <span class="comment">// 会在其他地方实例化</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt; 和它的接受initializer_list的构造器实例化in this file</span></span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="type">int</span>&gt; <span class="title">a2</span><span class="params">(a1)</span></span>; <span class="comment">// 在本文件里拷贝构造实例化了</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">compare</span>(a1[<span class="number">0</span>], a2[<span class="number">0</span>]); <span class="comment">// 实例化在其他位置</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>templateBuild.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;; <span class="comment">// 实例化这个类模板的所有成员</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意在定义的时候会实例化类模板的所有成员！</p>
</blockquote>
<p>编译此程序的时候一定要链接 <code>templateBuild.o</code> 和
<code>Application.o</code>。</p>
<p><strong>实例化定义会实例化所有成员</strong>
因为不知道程序使用了哪些成员，见上例。 ## 效率与灵活性
学习<code>shared_ptr</code>和<code>unique_ptr</code>的设计选择。<strong>前者</strong>很容易重载删除器，而<strong>后者</strong>的删除器是类型的一部分，需要在创建的时候传递给类型形参。这是两者功能决定的。</p>
<p><strong>运行时绑定删除器</strong></p>
<p><strong>编译时绑定删除器</strong></p>
<h1 id="模板实参推断">模板实参推断</h1>
<p>从函数实参确定模板实参的过程称为模板实参推断！</p>
<h2 id="类型转换与模板类型参数">类型转换与模板类型参数</h2>
<p>函数的<strong>形参使用</strong>了模板类型参数，<strong>只是会</strong>生成一个<strong>新</strong>的模板实例（大多数类型转换不存在的）！
<strong>只有</strong>下面的两种类型转换！ - const转换 -
数组或函数指针转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T, T)</span></span>; 				<span class="comment">// arguments are copied</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>; 	<span class="comment">// references</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">s2</span><span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1, s2); <span class="comment">// calls fobj(string, string); const is ignored</span></span><br><span class="line"><span class="built_in">fref</span>(s1, s2); <span class="comment">// calls fref(const string&amp;, const string&amp;)</span></span><br><span class="line"> <span class="comment">// uses premissible conversion to const on s1</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>], b[<span class="number">42</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b); <span class="comment">// calls f(int*, int*)</span></span><br><span class="line"><span class="built_in">fref</span>(a, b); <span class="comment">// error: array types don&#x27;t match</span></span><br></pre></td></tr></table></figure>
<p><strong>使用相同模板参数类型的函数形参</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="built_in">compare</span>(lng, <span class="number">1024</span>); <span class="comment">// error: cannot instantiate compare(long, int)</span></span><br></pre></td></tr></table></figure>
<p>如果想解决上面的问题，定义两份不同的模板参数类型。</p>
<p><strong>正常类型转换应用于普通的函数实参</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面就可以进行普通实参的类型转换</span></span><br><span class="line"><span class="built_in">print</span>(cout, <span class="number">42</span>); <span class="comment">// instantiates print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span><span class="params">(<span class="string">&quot;output&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(f, <span class="number">10</span>); <span class="comment">// uses print(ostream&amp;, int); converts f to ostream&amp;</span></span><br></pre></td></tr></table></figure>
<h2 id="函数模板显式实参">函数模板显式实参</h2>
<p>在一些情况下，编译器无法推断出模板实参的类型（这在函数返回类型与参数列表类型都不相同的时候发生）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1 cannot be deduced: it doesn&#x27;t appear in the function parameter list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>T1</code>的类型推断不出来，需要显式的指定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = <span class="built_in">sum</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(i, lng); <span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意可以按顺序指定多个模板参数，注意匹配的顺序。</p>
</blockquote>
<p>理解上面的提示之后就可以理解下面的糟糕的设计</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 糟糕的设计，为了指定T3，每次需要指定三个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2, T1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: can&#x27;t infer initial template parameters</span></span><br><span class="line"><span class="keyword">auto</span> val3 = <span class="built_in">alternative_sum</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(i, lng);</span><br><span class="line"><span class="comment">// ok: all three parameters are explicitly specified</span></span><br><span class="line"><span class="keyword">auto</span> val2 = <span class="built_in">alternative_sum</span>&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>, <span class="type">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>
<p><strong>正常类型转换应用于显式指定的实参</strong>
我们显式定义的函数实参，也可以进行正常的类型转换！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare(T,T)</span></span><br><span class="line"><span class="type">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng, <span class="number">1024</span>); 		<span class="comment">// error: template parameters don&#x27;t match</span></span><br><span class="line"><span class="built_in">compare</span>&lt;<span class="type">long</span>&gt;(lng, <span class="number">1024</span>); 	<span class="comment">// ok: instantiates compare(long, long)</span></span><br><span class="line"><span class="built_in">compare</span>&lt;<span class="type">int</span>&gt;(lng, <span class="number">1024</span>); 	<span class="comment">// ok: instantiates compare(int, int)</span></span><br></pre></td></tr></table></figure>
<h2 id="尾置返回类型与类型转换">尾置返回类型与类型转换</h2>
<p>显式指定返回类型会增加用户负担！比如我们使用迭代器时候</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;<span class="built_in">fcn</span>(It beg, It end)  <span class="comment">//该返回什么类型？</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="comment">// process the range</span></span><br><span class="line"> 	<span class="keyword">return</span> *beg; <span class="comment">// return a reference to an element from the range</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们指定函数应该返回<code>*beg</code>，可以用<code>decltype(*beg)</code>获取此表达式的类型，但是编译器在遇到参数列表之前beg<strong>不存在</strong>！
我们如下解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即返回类型后置于参数列表之后</span></span><br><span class="line"><span class="comment">// a trailing return lets us declare the return type after the parameter list is seen</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">// process the range</span></span><br><span class="line"> 	<span class="keyword">return</span> *beg; <span class="comment">// return a reference to an element from the range</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>*beg</code>的结果是左值，所有推断出来的类型是一个<strong>引用</strong>。</p>
<p><strong>进行类型转换的标准库模板类</strong>
有时候我们无法直接获得所需要的类型。比如上面的<code>fcn</code>我们向返回值而不是引用。那么我们迭代器提供的操作只能得到引用。那该怎么办？</p>
<p>使用标准库的<strong>类型转换模板</strong>（16.5节见如何实现）。下面使用<code>remove_reference</code>来解决上面问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须使用typename来表示type（public成员）是类型而不是static</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">// process the range</span></span><br><span class="line"> 	<span class="keyword">return</span> *beg; <span class="comment">// return a copy of an element from the range</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针和实参推断">函数指针和实参推断</h2>
<p>用函数模板初始化一个函数指针或为一个函数指针赋值。编译器用指针类型<strong>推断</strong>模板实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1 points to the instantiation int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in">int</span> (*pf1)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>
<p>如果不能从确定模板实参就会出现错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func的多个重载版本，c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>(*)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>(*)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span>(compare); <span class="comment">// error: 不知到实例化哪个compare</span></span><br></pre></td></tr></table></figure>
<p>我们可以显式指出模板实参来消除歧义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(compare&lt;<span class="type">int</span>&gt;); <span class="comment">// passing compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure>
<h2 id="模板实参推断和引用">模板实参推断和引用</h2>
<p>理解如何从函数调用进行类型推断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T &amp;p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>记住两点 1. 编译器会应用正确的引用绑定规则 2.
constt是底层的，不是顶层的</p>
<p><strong>从左值引用函数参数推断出类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>; <span class="comment">// argument must be an lvalue</span></span><br><span class="line"><span class="comment">// calls to f1 use the referred-to type of the argument as the template parameter type</span></span><br><span class="line"><span class="built_in">f1</span>(i); 	<span class="comment">// i is an int; template parameter T is int</span></span><br><span class="line"><span class="built_in">f1</span>(ci); <span class="comment">// ci is a const int; template parameter T is const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>); 	<span class="comment">// error: argument to a &amp; parameter must be an lvalue</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>; <span class="comment">// can take an rvalue</span></span><br><span class="line"><span class="comment">// parameter in f2 is const &amp;; const in the argument is irrelevant</span></span><br><span class="line"><span class="comment">// in each of these three calls, f2&#x27;s function parameter is inferred as const int&amp;</span></span><br><span class="line"><span class="built_in">f2</span>(i); 	<span class="comment">// i is an int; template parameter T is int</span></span><br><span class="line"><span class="built_in">f2</span>(ci); <span class="comment">// ci is a const int, but template parameter T is int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>); 	<span class="comment">// a const &amp; parameter can be bound to an rvalue; T is int</span></span><br></pre></td></tr></table></figure>
<p><strong>从右值引用函数参数推断出类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>); <span class="comment">// argument is an rvalue of type int; template parameter T is int</span></span><br></pre></td></tr></table></figure>
<p><strong>引用折叠和右值引用参数</strong>
一般来说<code>f3(i)</code>这种调用时不合法的，但是为了支持<code>move</code>这种标准库设施，有两个例外。
1.
右值引用参数推断。调用<code>f3(i)</code>的时候会推断<code>T</code>类型时<code>int&amp;</code>而不是<code>int</code>.
2. 引用<strong>折叠</strong>。允许折叠成右值引用。 - X&amp; &amp;,
X&amp; &amp;&amp;,X&amp;&amp; &amp;折叠成X&amp; - X&amp;&amp;
&amp;&amp;折叠成X &amp;&amp;</p>
<blockquote>
<p>引用折叠只能应用于间接创造引用的引用，如类型别名或模板参数。</p>
</blockquote>
<p>上面的两个规则导致两个重要的结果。 -
函数参数是指向模板类型参数的右值引用如（T
&amp;&amp;），可以绑定到左值，且 -
实参是左值，推断出来的实参类型是左值引用。函数参数被实例化为左值引用参数(T
&amp;)。</p>
<blockquote>
<p>上面的结合暗示可以传递任何类型实参给T&amp;&amp;的类型的函数参数。</p>
</blockquote>
<p><strong>编写接受右值引用参数的模板函数</strong></p>
<p><strong>编写接受右值引用参数的模板函数</strong>
模板参数可以推断为引用，会对模板内的代码产生令人惊讶的影响。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思考f3（42）和f3（i）的区别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T t = val; 			<span class="comment">// copy or binding a reference?</span></span><br><span class="line"> 	t = <span class="built_in">fcn</span>(t); 		<span class="comment">// does the assignment change only t or val and t?</span></span><br><span class="line"> 	<span class="keyword">if</span> (val == t) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// T是引用的这个判断一直是true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当代码涉及到类型可能是引用或普通类型的时候，编写正常的代码可能变得很困难。实际上，右值引用通常用于两种情况，模板转发或模板重载。</p>
</blockquote>
<p>使用右值引用的函数模板通常按下面的方式进行重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>; 		<span class="comment">// binds to nonconst rvalues</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>; <span class="comment">// lvalues and const rvalues</span></span><br></pre></td></tr></table></figure>
<h2 id="理解stdmove">理解std::move</h2>
<p><strong>std::move定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for the use of typename in the return type and the cast see § 16.1.3 (p. 670)</span></span><br><span class="line"><span class="comment">// remove_reference is covered in § 16.2.3 (p. 684)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">// static_cast covered in § 4.11.3</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过模板折叠，上面既可以绑定左值，也可以绑定右值。</p>
<p><strong>std::move是怎么工作的</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hi!&quot;</span>)</span>, s2</span>;</span><br><span class="line">s2 = std::<span class="built_in">move</span>(<span class="built_in">string</span>(<span class="string">&quot;bye!&quot;</span>)); <span class="comment">// ok: moving from an rvalue</span></span><br><span class="line">s2 = std::<span class="built_in">move</span>(s1); 			<span class="comment">// ok: but after the assigment ，s1的值不确定</span></span><br></pre></td></tr></table></figure>
<p>思考上面两个赋值过程（一个是左值，一个是右值）。</p>
<p><strong>从左值static_cast到一个右值引用时允许的</strong>
虽然隐式的转换不允许，但是用<code>static_cast</code>的显式的转换是允许的。
## 转发
有时某些函数需要把实参联同类型不变的转发给其他函数。包括是否是const，以及实参是左值还是右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受一个可调用的对象和两个参数的模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们传入有引用的<code>f</code>就会出现问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> &amp;v2)</span> <span class="comment">// note v2 is a reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">42</span>, i); 		<span class="comment">// f changes its argument i</span></span><br><span class="line"><span class="built_in">flip1</span>(f, j, <span class="number">42</span>); <span class="comment">// f called through flip1 leaves j unchanged</span></span><br></pre></td></tr></table></figure>
<p>实例化出的<code>flip1</code>是 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(<span class="type">void</span>(*fcn)(<span class="type">int</span>, <span class="type">int</span>&amp;), <span class="type">int</span> t1, <span class="type">int</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>
<strong>定义能保持类型信息的函数参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果把<code>f</code>替换成参数类型是右值引用的<code>g</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> &amp;&amp;i, <span class="type">int</span>&amp; j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出现错误，注意函数的参数都是左值表达式！</span></span><br><span class="line"><span class="built_in">flip2</span>(g, i, <span class="number">42</span>); <span class="comment">// error: can&#x27;t initialize int&amp;&amp; from an lvalue</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数的参数都是左值表达式！</p>
</blockquote>
<p><strong>调用的时候使用std::forward保持类型信息</strong>
std::forward必须使用显式模板实参来调用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg)); <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// forward&lt;T&gt;的返回类型是T&amp;&amp;.</span></span><br><span class="line"> 	<span class="built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="重载与模板">重载与模板</h1>
<blockquote>
<p>正确的定义一组重载函数模板需要对类型间的关系和模板函数允许的有限实参类型转换有深刻理解</p>
</blockquote>
<p><strong>编写重载模板</strong> 我们写一个调试中可能很有用的函数。 #
可变参数模板 参数包有<strong>两种</strong>，模板参数包和函数参数包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种参数包有对应关系</span></span><br><span class="line"><span class="comment">// Args is a template parameter pack; rest is a function parameter pack</span></span><br><span class="line"><span class="comment">// Args represents zero or more template type parameters</span></span><br><span class="line"><span class="comment">// rest represents zero or more function parameters</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="type">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span>;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>, d); <span class="comment">// three parameters in the pack</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>); <span class="comment">// two parameters in the pack</span></span><br><span class="line"><span class="built_in">foo</span>(d, s); <span class="comment">// one parameter in the pack</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">// empty pack</span></span><br></pre></td></tr></table></figure>
<p>上面的代码会实例化出来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> string&amp;, <span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">double</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>sizeof...运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(Args ... args)</span> </span>&#123;</span><br><span class="line"> 	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl; <span class="comment">// number of type parameters</span></span><br><span class="line"> 	cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl; <span class="comment">// number of function parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写可变参数函数模板">编写可变参数函数模板</h2>
<p>使用<code>initializer_list</code>定义接受可变实参的函数具有局限性。</p>
<blockquote>
<p>可变参数函数通常是递归的，理解下面的过程！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个print是为了终止递归！！</span></span><br><span class="line"><span class="comment">// this function must be declared before the variadic version of print is defined</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// no separator after the last element in the pack</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this version of print will be called for all but the last element in the pack</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>; <span class="comment">// print the first argument</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...); <span class="comment">// recursive call; print the other arguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包拓展">包拓展</h2>
<p>对于一个参数包，除了获取其大小，唯一能做的就是拓展。
例如上面的<code>print</code>就有两个拓展。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... rest)</span><span class="comment">// expand Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...); <span class="comment">// expandrest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理解包拓展</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call debug_rep on each argument in the call to print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="type">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">print</span>(os, <span class="built_in">debug_rep</span>(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们写下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">errorMsg</span>(cerr, fcnName, code.<span class="built_in">num</span>(), otherData, <span class="string">&quot;other&quot;</span>, item);</span><br></pre></td></tr></table></figure>
<p>就等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(cerr, <span class="built_in">debug_rep</span>(fcnName), <span class="built_in">debug_rep</span>(code.<span class="built_in">num</span>()), <span class="built_in">debug_rep</span>(otherData), <span class="built_in">debug_rep</span>(<span class="string">&quot;otherData&quot;</span>), <span class="built_in">debug_rep</span>(item));</span><br></pre></td></tr></table></figure>
<p>而下面有个可能<strong>错误</strong>的用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// passes the pack to debug_rep; print(os, debug_rep(a1, a2, ..., an))</span></span><br><span class="line"><span class="built_in">print</span>(os, <span class="built_in">debug_rep</span>(rest...)); <span class="comment">// error: no matching function to call</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的等价于下面的</span></span><br><span class="line"><span class="built_in">print</span>(cerr, <span class="built_in">debug_rep</span>(fcnName, code.<span class="built_in">num</span>(), otherData, <span class="string">&quot;otherData&quot;</span>, item));</span><br></pre></td></tr></table></figure>
<h2 id="转发参数包">转发参数包</h2>
<p>可以组合可变参数模板和forward机制来编写函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">chk_n_alloc</span>(); <span class="comment">// reallocates the StrVec if necessary</span></span><br><span class="line"> 	alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...); <span class="comment">//既拓展了Args也拓展了 args</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板特例化">模板特例化</h1>
<p>编写了单一模板，使其对所有模板实参都适合是不太现实。我们可能希望特例化模板。
我们的compare函数就是一个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first version; can compare any two types</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// second version to handle字符串常量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N, <span class="type">size_t</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;)[N], <span class="type">const</span> <span class="type">char</span> (&amp;)[M])</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们不能把指针转化为数组，所有第一个compare只能调用上面的第一个模板。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span>;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2); <span class="comment">// calls the first template</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>); <span class="comment">// calls the template with two nontype parameters</span></span><br></pre></td></tr></table></figure>
<strong>为了</strong>让第一个模板也能处理字符串指针，为第一个版本定义一个模板特例化。</p>
<p><strong>定义函数模板特例化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// special version of compare to handle pointers to character arrays</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p1, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p2)</span><span class="comment">//理解这里T为const char*</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数重载与模板特例化</strong>
特例化的本质是实例化一个模板，而不是重载它。
比如上面我们定义了三个版本的<code>compare</code>但是我们匹配</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>还是使用<strong>更精确</strong>的匹配，即特例化版本，而不是<code>template&lt;size_t N, size_t M&gt; int compare(const char (&amp;)[N], const char (&amp;)[M]);</code>的版本。</p>
<p>如果定义了一个非模板的compare函数也能匹配，那么会<strong>优先</strong>调用非模板的版本！</p>
<blockquote>
<p>模板和特例化应该声明在同一个头文件里，模板在前，特例化在后</p>
</blockquote>
<p><strong>类模板的特例化</strong>
我们来特例化标准库的hash模板（为了能让我们自己的类类型也能使用)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//open the std namespace so we can specialize std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; 			<span class="comment">// we&#x27;re defining a specialization with</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Sales_data&gt; <span class="comment">// the template parameter of Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="comment">// the type used to hash an unordered container must define these types</span></span><br><span class="line"> 	<span class="keyword">typedef</span> <span class="type">size_t</span> result_type;</span><br><span class="line"> 	<span class="keyword">typedef</span> Sales_data argument_type; <span class="comment">// by default, this type needs ==</span></span><br><span class="line"> 	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Sales_data&amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line"> 	<span class="comment">// our class uses synthesized copy control and default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">hash&lt;Sales_data&gt;::<span class="built_in">operator</span>()(<span class="type">const</span> Sales_data&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(s.bookNo) ^ <span class="built_in">hash</span>&lt;<span class="type">unsigned</span>&gt;()(s.units_sold) ^ <span class="built_in">hash</span>&lt;<span class="type">double</span>&gt;()(s.revenue);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// close the std namespace; note: no semicolon after the close curly</span></span><br></pre></td></tr></table></figure>
<p><strong>类模板的部分特例化</strong>
类模板的部分特例化本身就是一个模板，可以指定一部分参数<strong>或</strong>参数的一部分特性。介绍标准库的<code>remove_reference</code>类型（指定一部分特性）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最原始的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">remove_reference</span> &#123;</span><br><span class="line"> 	<span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// partial specializations that will be used for lvalue and rvalue references</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&gt; <span class="comment">// lvalue references</span></span><br><span class="line"> 	&#123; <span class="keyword">typedef</span> T type; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&amp;&gt; <span class="comment">// rvalue references</span></span><br><span class="line"> 	&#123; <span class="keyword">typedef</span> T type; &#125;;</span><br></pre></td></tr></table></figure>
<p>如下的演示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">// decltype(42) is int, uses the original template</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line"><span class="comment">// decltype(i) is int&amp;, uses first (T&amp;) partial specialization</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line"><span class="comment">// decltype(std::move(i)) is int&amp;&amp;, uses second (i.e., T&amp;&amp;) partial specialization</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(std::<span class="built_in">move</span>(i))&gt;::type c;</span><br></pre></td></tr></table></figure>
<p><strong>特例化成员而不是类</strong>
我们可以只特例化特定的成员函数而不是特例化整个模板。比如下面的<code>Bar</code>成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> 	<span class="built_in">Foo</span>(<span class="type">const</span> T &amp;t = <span class="built_in">T</span>()): <span class="built_in">mem</span>(t) &#123; &#125;</span><br><span class="line"> 	<span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"> 	T mem;</span><br><span class="line"> 	<span class="comment">// other members of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; 	<span class="comment">// we&#x27;re specializing a template</span></span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>() <span class="comment">// we&#x27;re specializing the Bar member of Foo&lt;int&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="comment">// do whatever specialized processing that applies to ints</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;string&gt; fs; <span class="comment">// instantiates Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.<span class="built_in">Bar</span>(); <span class="comment">// instantiates Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi; <span class="comment">// instantiates Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>(); <span class="comment">// uses our specialization of Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/myblog/tags/cpp/" rel="tag"># cpp</a>
              <a href="/myblog/tags/cpp-primer/" rel="tag"># cpp primer</a>
              <a href="/myblog/tags/book/" rel="tag"># book</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/myblog/2023/09/03/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="prev" title="cpp重载运算符和类型转换">
      <i class="fa fa-chevron-left"></i> cpp重载运算符和类型转换
    </a></div>
      <div class="post-nav-item">
    <a href="/myblog/2023/09/04/OpenGl%E5%85%A5%E9%97%A8/" rel="next" title="OpenGL入门">
      OpenGL入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.</span> <span class="nav-text">定义模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.2.</span> <span class="nav-text">类模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">模板参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.</span> <span class="nav-text">成员模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.5.</span> <span class="nav-text">控制实例化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="nav-number">2.</span> <span class="nav-text">模板实参推断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">类型转换与模板类型参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E5%8F%82"><span class="nav-number">2.2.</span> <span class="nav-text">函数模板显式实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">尾置返回类型与类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="nav-number">2.4.</span> <span class="nav-text">函数指针和实参推断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">模板实参推断和引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3stdmove"><span class="nav-number">2.6.</span> <span class="nav-text">理解std::move</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.</span> <span class="nav-text">重载与模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.1.</span> <span class="nav-text">编写可变参数函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E6%8B%93%E5%B1%95"><span class="nav-number">3.2.</span> <span class="nav-text">包拓展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E5%8C%85"><span class="nav-number">3.3.</span> <span class="nav-text">转发参数包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">模板特例化</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jxWu"
      src="/myblog/uploads/myimage.jpg">
  <p class="site-author-name" itemprop="name">jxWu</p>
  <div class="site-description" itemprop="description">record and up</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/myblog/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/myblog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/myblog/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jxWu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/myblog/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/myblog/lib/anime.min.js"></script>
  <script src="/myblog/lib/velocity/velocity.min.js"></script>
  <script src="/myblog/lib/velocity/velocity.ui.min.js"></script>

<script src="/myblog/js/utils.js"></script>

<script src="/myblog/js/motion.js"></script>


<script src="/myblog/js/schemes/pisces.js"></script>


<script src="/myblog/js/next-boot.js"></script>


  <script defer src="/myblog/lib/three/three.min.js"></script>
    <script defer src="/myblog/lib/three/three-waves.min.js"></script>
    <script defer src="/myblog/lib/three/canvas_lines.min.js"></script>
    <script defer src="/myblog/lib/three/canvas_sphere.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
