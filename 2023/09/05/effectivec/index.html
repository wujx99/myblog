<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/myblog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/myblog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/myblog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/myblog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/myblog/css/main.css">


<link rel="stylesheet" href="/myblog/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/myblog/lib/pace/pace-theme-bounce.min.css">
  <script src="/myblog/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wujx99.github.io","root":"/myblog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="《effective c++》读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="effective c++">
<meta property="og:url" content="https://wujx99.github.io/myblog/2023/09/05/effectivec/index.html">
<meta property="og:site_name" content="blogs&amp;record">
<meta property="og:description" content="《effective c++》读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ed6b84018e52438a86e9d811a8fe2348.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/00ab16bb72b14d149db0e79389d74e7f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/493a5b9032eb40e2b06375778fc4ca5d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7d656ff20f184fe18c2f2773451c1461.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1b5d10bab42e4d31abd9a0d2fa6d67ec.png">
<meta property="article:published_time" content="2023-09-05T07:26:18.000Z">
<meta property="article:modified_time" content="2023-09-06T05:30:50.613Z">
<meta property="article:author" content="jxWu">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="effective c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/ed6b84018e52438a86e9d811a8fe2348.png">

<link rel="canonical" href="https://wujx99.github.io/myblog/2023/09/05/effectivec/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>effective c++ | blogs&record</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/myblog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blogs&record</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/myblog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/myblog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/myblog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/myblog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/myblog/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/myblog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wujx99.github.io/myblog/2023/09/05/effectivec/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/myblog/uploads/myimage.jpg">
      <meta itemprop="name" content="jxWu">
      <meta itemprop="description" content="record and up">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blogs&record">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          effective c++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-05 15:26:18" itemprop="dateCreated datePublished" datetime="2023-09-05T15:26:18+08:00">2023-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-06 13:30:50" itemprop="dateModified" datetime="2023-09-06T13:30:50+08:00">2023-09-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>《effective c++》读书笔记</p>
<span id="more"></span>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>declaration：</li>
<li><code>object</code>:包括内置类型和用户自定义类型</li>
<li>signature：函数的参数和返回类型</li>
<li>definition：提供编译器declaratin没有的实现细节；对于对象来说，定义就是编译器为对象保留内存。</li>
<li>initialization：给对象第一次的值</li>
<li>default constructor：不用提供参数就能调用，要么没有参数，要么参数有默认值</li>
<li>copy constructor：参数传值很有用</li>
<li>copy assignment operator：</li>
<li>STL</li>
<li>function object：像函数一样的对象</li>
<li>undefined behavior：</li>
<li>interface：</li>
<li>client：</li>
<li>ctor，dtor：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x   <span class="comment">//declaration</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x  			<span class="comment">// definition</span></span><br></pre></td></tr></table></figure>
<h2 id="命名习惯"><a href="#命名习惯" class="headerlink" title="命名习惯"></a>命名习惯</h2><p>pt意味着指向t对象的指针<br>rt意味着指向t对象的引用</p>
<h2 id="对多线程的考虑"><a href="#对多线程的考虑" class="headerlink" title="对多线程的考虑"></a>对多线程的考虑</h2><h2 id="TR1-and-Boost"><a href="#TR1-and-Boost" class="headerlink" title="TR1 and Boost"></a>TR1 and Boost</h2><h1 id="chap01：accustoming-yourself-to-c"><a href="#chap01：accustoming-yourself-to-c" class="headerlink" title="chap01：accustoming yourself  to c++"></a>chap01：accustoming yourself  to c++</h1><h2 id="item1：view-C-as-a-federation-of-languages"><a href="#item1：view-C-as-a-federation-of-languages" class="headerlink" title="item1：view C++ as a federation of languages"></a>item1：view C++ as a federation of languages</h2><p>c++是一系列的语言特性的集合，你最好在不同的使用方式下切换。识别出主要的子语言：</p>
<ul>
<li>c</li>
<li>OO c++</li>
<li>Template c++</li>
<li>STL</li>
</ul>
<p>举例来说，内置类型pass-by-value比pass-by-reference更高效，OO中pass-by-reference-to-const更有效，在TMP中你甚至不知道你的类型是什么。STL中更像是c，所以又回到pass-by-value。所以<strong>没有统一的规则</strong>，记住这四种子语言。</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Rules for effective C++ programming vary, depending on the part of C++ you are using</p>
</blockquote>
<h2 id="Item2-perfer-consts-enums-and-inlines-to-defines"><a href="#Item2-perfer-consts-enums-and-inlines-to-defines" class="headerlink" title="Item2:perfer consts,enums,and inlines to #defines"></a>Item2:perfer consts,enums,and inlines to #defines</h2><p>其实应该说“相较于预处理器应该更喜欢编译器”</p>
<p>宏定义不会出现在符号表，且经过预处理器后会有多处替代，<strong>不如</strong>声明const常量！</p>
<p>有两点需要注意</p>
<ol>
<li>const指针：因为常量一般放在头文件里面，所以不能被更改。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要两个const保证指针的值和字符串不会改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个更好的实践是</span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">authorName</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span>; </span><br></pre></td></tr></table></figure></li>
<li>类依赖的常量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns = <span class="number">5</span>; 	<span class="comment">// constant declaration</span></span><br><span class="line">	<span class="type">int</span> scores[NumTurns]; 			<span class="comment">// use of constant</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意上面要声明<code>static</code>,上面的<code>NumTurns</code>是declaration，不是definition。</p>
<p>通常，c++要求您为使用的任何东西提供定义，但是类依赖的静态的和整型(例如，整数、字符、bool)的常量是<strong>一个例外</strong>。</p>
<p>如果不是整型的话可以这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CostEstimate</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">double</span> FudgeFactor;<span class="comment">// declaration of static class</span></span><br><span class="line">	... 							<span class="comment">// constant; goes in header file</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> 						<span class="comment">// definition of static class</span></span><br><span class="line">CostEstimate::FudgeFactor = <span class="number">1.35</span>; 	<span class="comment">// constant; goes in impl. file</span></span><br></pre></td></tr></table></figure>

<p>老的编译器不支持声明时赋值，但是类的其他成员需要常量值，这时要使用”the enum hack”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;; 	<span class="comment">// “the enum hack” — makes</span></span><br><span class="line">							<span class="comment">// NumTurns a symbolic name for 5</span></span><br><span class="line">	<span class="type">int</span> scores[NumTurns]; 	<span class="comment">// fine</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>enum</strong>更像#define，不能获取其地址，也就能防止访问和修改。</p>
<blockquote>
<p>好的编译器不会为整型的const对象留出存储空间(除非创建指向该对象的指针或引用),为什么？</p>
</blockquote>
<p>不要用宏替代函数，有更好的模板函数的实现。</p>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ For simple constants, prefer const objects or enums to #defines.<br>✦ For function-like macros, prefer inline functions to #defines.</p>
</blockquote>
<h2 id="Item3：use-const-whenever-possible"><a href="#Item3：use-const-whenever-possible" class="headerlink" title="Item3：use const whenever possible."></a>Item3：use const whenever possible.</h2><p>stl的iterator使用指针建模的，分为<code>iterator</code>和<code>const_iterator</code>，对iterator的const限制是对指针的限制而不是对指针指向的值的限制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = 	<span class="comment">// iter acts like a T* const</span></span><br><span class="line">vec.<span class="built_in">begin</span>();</span><br><span class="line">*iter = <span class="number">10</span>; 								<span class="comment">// OK, changes what iter points to</span></span><br><span class="line">++iter; 									<span class="comment">// error! iter is const</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator cIter = 	<span class="comment">// cIter acts like a const T* vec.begin();</span></span><br><span class="line">*cIter = <span class="number">10</span>; 								<span class="comment">// error! *cIter is const</span></span><br><span class="line">++cIter; 									<span class="comment">// fine, changes cIter</span></span><br></pre></td></tr></table></figure>

<p>const在函数上的使用就更多了。</p>
<p>return value声明成const的原因，为了不让返回的值作为左值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>
<p>上面如果不声明const就会有下面的语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line">(a * b) = c; 	<span class="comment">// invoke operator= on the</span></span><br><span class="line">				<span class="comment">// result of a*b!</span></span><br></pre></td></tr></table></figure>

<p><strong>—-const Member Functions</strong><br>一个成员函数可以有const和constness的重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> 	<span class="comment">// operator[] for</span></span><br><span class="line">	&#123; <span class="keyword">return</span> text[position]; &#125; 							<span class="comment">// const objects</span></span><br><span class="line">	<span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) 				<span class="comment">// operator[] for</span></span><br><span class="line">	&#123; <span class="keyword">return</span> text[position]; &#125; 							<span class="comment">// non-const objects</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 	std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的重载的<strong>返回类型也不同</strong>，这是合理的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>]; 	<span class="comment">// calls non-const</span></span><br><span class="line">						<span class="comment">// TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>]; 	<span class="comment">// calls const TextBlock::operator[]</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>];	 	<span class="comment">// fine — reading a</span></span><br><span class="line">						<span class="comment">// non-const TextBlock</span></span><br><span class="line">tb[<span class="number">0</span>] = ’x’; 			<span class="comment">// fine — writing a</span></span><br><span class="line">						<span class="comment">// non-const TextBlock</span></span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>]; 	<span class="comment">// fine — reading a</span></span><br><span class="line">						<span class="comment">// const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = ’x’; 			<span class="comment">// error! — writing a</span></span><br><span class="line">						<span class="comment">// const TextBlock</span></span><br></pre></td></tr></table></figure>
<p>注意上面<code>[]</code>返回的都是<strong>引用</strong>，而<strong>不是</strong>内置类型<code>char</code>，否则就不能被赋值（就算能赋值，也是传值的，并不是传地址）。</p>
<blockquote>
<p>是不是const类对象只能访问const成员函数吗？是对的，const对象的<code>this</code>指针加入了顶层const，只能传入到const成员函数里。</p>
</blockquote>
<p>现在考虑一下成员函数设置成const的哲学，有两种观点：bitwise constness和logical constness。</p>
<p>bitwise constness<strong>有漏洞</strong>，当cosnt成员函数返回非常量的引用还是可以修改const类对象的值。</p>
<p>引入了logical constness的理念和mutable</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> *pText;</span><br><span class="line">	<span class="keyword">mutable</span> std::<span class="type">size_t</span> textLength; <span class="comment">// these data members may</span></span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">bool</span> lengthIsValid; 	<span class="comment">// always be modified, even in</span></span><br><span class="line">&#125;; 									<span class="comment">// const member functions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在const成员函数内也修改了</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">textLength = std::<span class="built_in">strlen</span>(pText); 	<span class="comment">// now fine</span></span><br><span class="line">lengthIsValid = <span class="literal">true</span>; 				<span class="comment">// also fine</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>—–Avoiding Duplication in const and Non-const Member Functions</strong></p>
<p>mutable是一个避免bitwise-constness-is-not-what-i-had-in-mind解决方案，但是不能解决所有const-related的困难，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	... <span class="comment">// do bounds checking</span></span><br><span class="line">	... <span class="comment">// log access data</span></span><br><span class="line">	... <span class="comment">// verify data integrity</span></span><br><span class="line">	<span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)</span><br><span class="line">&#123;</span><br><span class="line">	... <span class="comment">// do bounds checking</span></span><br><span class="line">	... <span class="comment">// log access data</span></span><br><span class="line">	... <span class="comment">// verify data integrity</span></span><br><span class="line">	<span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 	std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般来说cast是一个不好的选择，但在这里却还不错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> <span class="comment">// same as before</span></span><br><span class="line">	&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">return</span> text[position];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) 			<span class="comment">// now just calls const op[]</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">			<span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;( 						<span class="comment">// cast away const on</span></span><br><span class="line">													<span class="comment">// op[]’s return type;</span></span><br><span class="line">			<span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>) 	<span class="comment">// add const to *this’s type;</span></span><br><span class="line">			[position] 								<span class="comment">// call const version of op[]</span></span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>必须先cast成const对象，否则无限递归调用，</p>
<blockquote>
<p>item27介绍static-cast&#x2F;const-cast</p>
</blockquote>
<p>注意上面的反面的调用时不合适的，即用const成员函数调用nonconst的成员函数。</p>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ Declaring something const helps compilers detect usage errors. const<br>can be applied to objects at any scope, to function parameters and<br>return types, and to member functions as a whole.<br>✦ Compilers enforce bitwise constness, but you should program using<br>logical constness.<br>✦ When const and non-const member functions have essentially identical implementations, code duplication can be avoided by having the<br>non-const version call the const version.</p>
</blockquote>
<h2 id="item4-make-sure-that-object-are-initialized-before-they’re-used"><a href="#item4-make-sure-that-object-are-initialized-before-they’re-used" class="headerlink" title="item4:make sure that object are initialized before they’re used"></a>item4:make sure that object are initialized before they’re used</h2><p>c++的c部分可能由于运行时开销就不保证初始化，但是非c部分可能就不同了。</p>
<p>所以<strong>内置类型</strong>就手动初始化，<strong>其他的类型</strong>构造器初始每个类数据成员。</p>
<p>要注意初始化和赋值的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123; 				<span class="comment">// ABEntry = “Address Book Entry”</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">			<span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string theName;</span><br><span class="line">	std::string theAddress;</span><br><span class="line">	std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">	<span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line"><span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">	theName = name; 			<span class="comment">// these are all assignments,</span></span><br><span class="line">	theAddress = address; 		<span class="comment">// not initializations</span></span><br><span class="line">	thePhones = phones;</span><br><span class="line">	numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好改成（成员初始化列表内<strong>拷贝初始化或默认初始化</strong>），</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line"><span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">: <span class="built_in">theName</span>(name),</span><br><span class="line"><span class="built_in">theAddress</span>(address), 		<span class="comment">// these are now all initializations</span></span><br><span class="line"><span class="built_in">thePhones</span>(phones),</span><br><span class="line"><span class="built_in">numTimesConsulted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125; 							<span class="comment">// the ctor body is now empty</span></span><br></pre></td></tr></table></figure>

<p>上面的<strong>内置类型</strong><code>numTimesConsulted</code>放在ctor函数体内赋值还是在成员初始化列表内初始化都无所谓。</p>
<p>有时候成员初始化列表<strong>是必须</strong>的，比如const成员和引用不能被赋值（见item5）。</p>
<p>如果有多个构造器和很多成员，这时候可以声明一个函数进行赋值<strong>也是</strong>合理的。一般来说，真正的成员初始化(通过初始化列表)<strong>优于</strong>通过赋值进行的伪初始化。</p>
<p>成员初始化的顺序：</p>
<p>当一切都按上面的做好了后，只有一件事情需要担心：<strong>在不同的translation units中定义的non-local static对象的初始化顺序</strong>。</p>
<p>static object不同于stack和heap中的对象，lifetime是整个程序。<strong>包含</strong>：全局对象，namespace中的对象，类中声明static的对象，函数中声明static的对象，<strong>文件域</strong>中声明static的对象。<br>其中<strong>函数中</strong>的static对象是局部的（只对函数可见），其他是非local的。</p>
<blockquote>
<p>专题作用域和可见域1<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cygalaxy/p/7103674.html">https://www.cnblogs.com/cygalaxy/p/7103674.html</a><br>2<a target="_blank" rel="noopener" href="http://17de.com/library/CPP/ls15.htm">http://17de.com/library/CPP/ls15.htm</a></p>
</blockquote>
<p>translation unit是单个object file的源代码，其中的<code>#include</code>file都加入其中了。</p>
<p>一个translation unit的static对象用另一个translation unit的static对象初始化会导致问题。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; 					<span class="comment">// from your library’s header file</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="type">const</span></span>; 	<span class="comment">// one of many member functions ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs; 				<span class="comment">// declare object for clients to use</span></span><br><span class="line">									<span class="comment">// (“tfs” = “the file system” ); definition</span></span><br><span class="line">									<span class="comment">// is in some .cpp file in your library</span></span><br></pre></td></tr></table></figure>
<p>FileSystem对象显然是non-trivial的，因此在构造tfs对象之前使用它将是灾难性的。<br>比如用户如下使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; 						<span class="comment">// created by library client</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Directory</span>( params ); ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>(); <span class="comment">// use the tfs object ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以这样使用：<br><code>Directory tempDir( params ); // directory for temporary files</code></p>
<p>但是<strong>一定</strong>要保证tfs在tempDir之前初始化。想要保证初始化的顺序是不可能的。</p>
<p>该怎么办呢？只能更改设计！（单例模式的一种实现）用local static对象代替：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;; 					<span class="comment">// as before</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> 							<span class="comment">// this replaces the tfs object; it could be</span></span></span><br><span class="line"><span class="function"></span>&#123; 											<span class="comment">// static in the FileSystem class</span></span><br><span class="line">	<span class="type">static</span> FileSystem fs; 					<span class="comment">// define and initialize a local static object</span></span><br><span class="line">	<span class="keyword">return</span> fs; 								<span class="comment">// return a reference to it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;; 					<span class="comment">// as before</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params ) 				<span class="comment">// as before, except references to tfs are</span></span><br><span class="line">&#123; 											<span class="comment">// now to tfs()</span></span><br><span class="line">	...</span><br><span class="line">	std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span> 						<span class="comment">// this replaces the tempDir object; it</span></span></span><br><span class="line"><span class="function"></span>&#123; 											<span class="comment">// could be static in the Directory class</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Directory <span class="title">td</span><span class="params">( params )</span></span>; 			<span class="comment">// define/initialize local static object</span></span><br><span class="line">	<span class="keyword">return</span> td; 								<span class="comment">// return reference to it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这种关于non-const的static对象的初始化在多线程程序中会出现问题。</p>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ Manually initialize objects of built-in type, because C++ only sometimes initializes them itself.<br>✦ In a constructor, prefer use of the member initialization list to assignment inside the body of the constructor. List data members in<br>the initialization list in the same order they’re declared in the class.<br>✦ Avoid initialization order problems across translation units by replacing non-local static objects with local static objects.</p>
</blockquote>
<h1 id="chap02-ctor-dtor-and-assignment-operators"><a href="#chap02-ctor-dtor-and-assignment-operators" class="headerlink" title="chap02:ctor,dtor,and assignment operators"></a>chap02:ctor,dtor,and assignment operators</h1><h2 id="item3：konw-what-functions-c-silently-writes-and-calls"><a href="#item3：konw-what-functions-c-silently-writes-and-calls" class="headerlink" title="item3：konw what functions c++ silently writes and calls."></a>item3：konw what functions c++ silently writes and calls.</h2><p>当写下：<br><code>class Empty&#123;&#125;;</code><br>等价于写下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Empty</span>() &#123; ... &#125; 							<span class="comment">// default constructor</span></span><br><span class="line">	<span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs) &#123; ... &#125; 			<span class="comment">// copy constructor</span></span><br><span class="line">	~<span class="built_in">Empty</span>() &#123; ... &#125; 							<span class="comment">// destructor — see below</span></span><br><span class="line">												<span class="comment">// for whether it’s virtual</span></span><br><span class="line">	Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs) &#123; ... &#125; 	<span class="comment">// copy assignment operator</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意生成的析构器是非虚的（除非从基类继承虚性质）</p>
<p>拷贝赋值运算符有一些限制，比如下面的引用和const成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// this ctor no longer takes a const name, because nameValue</span></span><br><span class="line">		<span class="comment">// is now a reference-to-non-const string. The char* constructor</span></span><br><span class="line">		<span class="comment">// is gone, because we must have a string to refer to.</span></span><br><span class="line">	<span class="built_in">NamedObject</span>(std::string&amp; name, <span class="type">const</span> T&amp; value);</span><br><span class="line">	... <span class="comment">// as above, assume no</span></span><br><span class="line">		<span class="comment">// operator= is declared</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string&amp; nameValue; <span class="comment">// this is now a reference</span></span><br><span class="line">	<span class="type">const</span> T objectValue; 	<span class="comment">// this is now const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面会发生什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">newDog</span><span class="params">(<span class="string">&quot;Persephone&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">oldDog</span><span class="params">(<span class="string">&quot;Satch&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(newDog, <span class="number">2</span>)</span></span>; 	<span class="comment">// when I originally wrote this, our</span></span><br><span class="line">								<span class="comment">// dog Persephone was about to</span></span><br><span class="line">								<span class="comment">// have her second birthday</span></span><br><span class="line"><span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(oldDog, <span class="number">36</span>)</span></span>; <span class="comment">// the family dog Satch (from my</span></span><br><span class="line">								<span class="comment">// childhood) would be 36 if she</span></span><br><span class="line">								<span class="comment">// were still alive</span></span><br><span class="line">p = s; 							<span class="comment">// what should happen to</span></span><br><span class="line">								<span class="comment">// the data members in p?</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>c++不允许引用指向新的对象吗？</p>
</blockquote>
<p>上面的代码编译器会拒绝编译！</p>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ Compilers may implicitly generate a class’s default constructor, copy constructor, copy assignment operator, and destructor.</p>
</blockquote>
<h2 id="item6-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><a href="#item6-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want" class="headerlink" title="item6:explicitly disallow the use of compiler-generated functions you do not want."></a>item6:explicitly disallow the use of compiler-generated functions you do not want.</h2><p><code>class HomeForSale &#123; ... &#125;;</code><br>每个house都是独一无二，拷贝没有什么意义！所以进行下面的操作限制拷贝（声明<strong>不定义</strong>且private）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">HomeForSale</span>(<span class="type">const</span> HomeForSale&amp;); 		<span class="comment">// declarations only</span></span><br><span class="line">	HomeForSale&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果声明了友元或内部的调用上面的函数会在链接时候发生错误（没有定义函数）。可以把问题移动到编译期报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>: 										<span class="comment">// allow construction</span></span><br><span class="line">	<span class="built_in">Uncopyable</span>() &#123;&#125; 							<span class="comment">// and destruction of</span></span><br><span class="line">	~<span class="built_in">Uncopyable</span>() &#123;&#125; 							<span class="comment">// derived objects...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;); 				<span class="comment">// ...but prevent copying</span></span><br><span class="line">	Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span>: <span class="keyword">private</span> Uncopyable &#123; 		<span class="comment">// class no longer</span></span><br><span class="line">	... 										<span class="comment">// declares copy ctor or</span></span><br><span class="line">&#125;; 												<span class="comment">// copy assign. operator</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么要private继承？Uncopyable的析构器不必声明为虚？后面再回来看看</p>
</blockquote>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ To disallow functionality automatically provided by compilers, declare the corresponding member functions private and give no implementations. Using a base class like Uncopyable is one way to do this.</p>
</blockquote>
<h2 id="item7-declare-dtors-virtual-in-polymorphic-base-classes"><a href="#item7-declare-dtors-virtual-in-polymorphic-base-classes" class="headerlink" title="item7:declare dtors virtual in polymorphic base classes"></a>item7:declare dtors virtual in polymorphic base classes</h2><p><em>factory function</em></p>
<p>如果不是为了作为基类<strong>就不要</strong>设置虚析构器，不这样的话就会引入虚机制破坏与其他语言的相容性和可移植性。<br><strong>summary</strong>: declare a virtual destructor in a class if and only if that class contains at least one virtual function</p>
<p>不要继承没有virtual析构器的类。</p>
<blockquote>
<p>abstract类和纯虚函数的关系,纯虚析构器还<strong>必须</strong>要有定义！<br>纯虚函数不能创建对象！</p>
</blockquote>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ Polymorphic base classes should declare virtual destructors. If a class has any virtual functions, it should have a virtual destructor.<br>✦ Classes not designed to be base classes or not designed to be used polymorphically should not declare virtual destructors.</p>
</blockquote>
<h2 id="item8：prevent-exceptions-from-leaving-dtor"><a href="#item8：prevent-exceptions-from-leaving-dtor" class="headerlink" title="item8：prevent exceptions from leaving dtor."></a>item8：prevent exceptions from leaving dtor.</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	~<span class="built_in">Widget</span>() &#123; ... &#125; 		<span class="comment">// assume this might emit an exception</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Widget&gt; v;</span><br><span class="line">	...</span><br><span class="line">&#125; 							<span class="comment">// v is automatically destroyed here</span></span><br></pre></td></tr></table></figure>
<p>假设<code>v</code>中有10个<code>Widget</code>。如果在析构<code>v</code>的时候，第一个<code>widget</code>析构器报出exception，另一个也报出。<strong>两个exception同时报出会出现问题</strong>。</p>
<p>怎么解决这个问题呢？设计一个资源管理的类。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>; 	<span class="comment">// function to return</span></span><br><span class="line">									<span class="comment">// DBConnection objects; params</span></span><br><span class="line">									<span class="comment">// omitted for simplicity</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>; 					<span class="comment">// close connection; throw an</span></span><br><span class="line">&#125;; 									<span class="comment">// exception if closing fails</span></span><br></pre></td></tr></table></figure>
<p>管理<code>DBConnection</code>对象的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123; 			<span class="comment">// class to manage DBConnection</span></span><br><span class="line"><span class="keyword">public</span>: 				<span class="comment">// objects ...</span></span><br><span class="line">	~<span class="built_in">DBConn</span>() 			<span class="comment">// make sure database connections</span></span><br><span class="line">	&#123; 					<span class="comment">// are always closed</span></span><br><span class="line">		db.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如下的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; 										<span class="comment">// open a block</span></span><br><span class="line">	<span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>; <span class="comment">// create DBConnection object</span></span><br><span class="line">										<span class="comment">// and turn it over to a DBConn</span></span><br><span class="line">										<span class="comment">// object to manage</span></span><br><span class="line">	... 								<span class="comment">// use the DBConnection object</span></span><br><span class="line">										<span class="comment">// via the DBConn interface</span></span><br><span class="line">								&#125; 		<span class="comment">// at end of block, the DBConn</span></span><br><span class="line">										<span class="comment">// object is destroyed, thus</span></span><br><span class="line">										<span class="comment">// automatically calling close on</span></span><br><span class="line">										<span class="comment">// the DBConnection object</span></span><br></pre></td></tr></table></figure>
<p>如果<code>close()</code>能被正确的调用上面的方案就可行，但如果产生exception的话就不好说了，有两种方案：</p>
<ol>
<li>终止程序：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">	<span class="built_in">catch</span> (...) &#123;</span><br><span class="line">		make log entry that the call to close failed;</span><br><span class="line">		std::<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.吞下异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">	<span class="built_in">catch</span> (...) &#123;</span><br><span class="line">		make log entry that the call to close failed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个更好的策略（让用户能够react to出现的问题并去处理，下面设计了<code>close()</code>函数<strong>给用户</strong>使用）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> 											<span class="comment">// new function for</span></span></span><br><span class="line"><span class="function">	</span>&#123; 														<span class="comment">// client use</span></span><br><span class="line">		db.<span class="built_in">close</span>();</span><br><span class="line">		closed = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">DBConn</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123; 											<span class="comment">// close the connection</span></span><br><span class="line">				db.<span class="built_in">close</span>(); 								<span class="comment">// if the client didn’t</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (...) &#123; 									<span class="comment">// if closing fails,</span></span><br><span class="line">				make log entry that call to close failed; 	<span class="comment">// note that and </span></span><br><span class="line">				... 										<span class="comment">// terminate or swallow</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DBConnection db;</span><br><span class="line">	<span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Things to Remember</strong><br>✦ Destructors should never emit exceptions. If functions called in a destructor may throw, the destructor should catch any exceptions,<br>then swallow them or terminate the program.<br>✦ If class clients need to be able to react to exceptions thrown during an operation, the class should provide a regular (i.e., non-destructor) function that performs the operation.</p>
</blockquote>
<h2 id="item9-never-call-virtual-functions-during-ctor-or-dtor"><a href="#item9-never-call-virtual-functions-during-ctor-or-dtor" class="headerlink" title="item9:never call virtual functions during ctor or dtor."></a>item9:never call virtual functions during ctor or dtor.</h2><p>下面是股票交易的实例且有log</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123; 							<span class="comment">// base class for all</span></span><br><span class="line"><span class="keyword">public</span>: 										<span class="comment">// transactions</span></span><br><span class="line">	<span class="built_in">Transaction</span>();	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; 	<span class="comment">// make type-dependent</span></span><br><span class="line">												<span class="comment">// log entry</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line">Constructors, Destructors, <span class="keyword">operator</span>= Item <span class="number">9</span> <span class="number">49</span></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>() 						<span class="comment">// implementation of</span></span><br><span class="line">&#123; 												<span class="comment">// base class ctor</span></span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">logTransaction</span>(); 							<span class="comment">// as final action, log this</span></span><br><span class="line">&#125; 												<span class="comment">// transaction</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123; 		<span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>; 		<span class="comment">// how to log trans-</span></span><br><span class="line">												<span class="comment">// actions of this type </span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTransaction</span>: <span class="keyword">public</span> Transaction &#123; 	<span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>; 		<span class="comment">// how to log trans-</span></span><br><span class="line">												<span class="comment">// actions of this type</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当写下：<br><code>BuyTransaction b;</code><br>你能发现问题吗？（有了object model的知识理解这里就简单多了）</p>
<p>下面的代码也是同样的问题但是更加的隐蔽：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Transaction</span>()</span><br><span class="line">	&#123; <span class="built_in">init</span>(); &#125; 				<span class="comment">// call to non-virtual...</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="built_in">logTransaction</span>(); 		<span class="comment">// ...that calls a virtual!</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个解决方案是非虚，派生类给其传递基类信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>;	<span class="comment">// now a non-</span></span><br><span class="line">															<span class="comment">// virtual func</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">logTransaction</span>(logInfo); 								<span class="comment">// now a non-</span></span><br><span class="line">&#125; 															<span class="comment">// virtual call</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BuyTransaction</span>( parameters )</span><br><span class="line">	: <span class="built_in">Transaction</span>(<span class="built_in">createLogString</span>( parameters )) 			<span class="comment">// pass log info</span></span><br><span class="line">	&#123; ... &#125; 												<span class="comment">// to base class</span></span><br><span class="line">	... 													<span class="comment">// constructor</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> std::string <span class="title">createLogString</span><span class="params">( parameters )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意上面的函数<code>creatLogString()</code>是static的（<strong>很重要</strong>！）。这样不会使用到派生类未初始化的成员！</p>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ Don’t call virtual functions during construction or destruction, because such calls will never go to a more derived class than that of the currently executing constructor or destructor.</p>
</blockquote>
<h2 id="item10-have-assignment-operators-return-a-reference-to-this"><a href="#item10-have-assignment-operators-return-a-reference-to-this" class="headerlink" title="item10:have assignment operators return a reference to *this"></a>item10:have assignment operators return a reference to *this</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>; <span class="comment">// chain of assignments</span></span><br></pre></td></tr></table></figure>
<p>因为赋值是右结合的：<br><code>x = (y = (z = 15));</code><br>遵循惯例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)	<span class="comment">// return type is a reference to</span></span><br><span class="line">&#123; 										<span class="comment">// the current class</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>; 						<span class="comment">// return the left-hand object</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs) 	<span class="comment">// the convention applies to</span></span><br><span class="line">&#123; 										<span class="comment">// +=, -=, *=, etc.</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="type">int</span> rhs) 				<span class="comment">// it applies even if the</span></span><br><span class="line">	&#123; 									<span class="comment">// operator’s parameter type ... 	</span></span><br><span class="line">										<span class="comment">// is unconventional</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Things to Remember</strong><br>✦ Have assignment operators return a reference to <code>*this</code>.</p>
</blockquote>
<h2 id="item11-handle-assignment-to-self-in-operator"><a href="#item11-handle-assignment-to-self-in-operator" class="headerlink" title="item11: handle assignment to self in operator&#x3D;"></a>item11: handle assignment to self in operator&#x3D;</h2><p>别名的存在可能是你在使用之前释放了内存。<br>下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	Bitmap *pb; 						<span class="comment">// ptr to a heap-allocated object</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) 	<span class="comment">// unsafe impl. of operator=</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> pb; 							<span class="comment">// stop using current bitmap</span></span><br><span class="line">	pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb); 			<span class="comment">// start using a copy of rhs’s bitmap</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>; 						<span class="comment">// see Item 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>=</code>两个的对象相同，上面会有什么问题？<br>传统的解决方案是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// identity test: if a self-assignment,</span></span><br><span class="line">									<span class="comment">// do nothing</span></span><br><span class="line">	<span class="keyword">delete</span> pb;</span><br><span class="line">	pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<code>operator=</code>不仅仅是self-assignment-unsafe,而且是exception-unsafe。如果<code>new Bitmap</code>出现异常，那么pb指向了被删除的bitmap。</p>
<p>下面是一种实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Bitmap *pOrig = pb; 		<span class="comment">// remember original pb</span></span><br><span class="line">	pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb); 	<span class="comment">// point pb to a copy of rhs’s bitmap</span></span><br><span class="line">	<span class="keyword">delete</span> pOrig; 				<span class="comment">// delete the original pb</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方案是使用“copy and swap”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; 				<span class="comment">// exchange *this’s and rhs’s data; ... 	</span></span><br><span class="line">											<span class="comment">// see Item 29 for details</span></span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Widget <span class="built_in">temp</span>(rhs); 						<span class="comment">// make a copy of rhs’s data</span></span><br><span class="line">	<span class="built_in">swap</span>(temp); 							<span class="comment">// swap *this’s data with the copy’s</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要item29的知识<code>swap()</code>。还有变种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs) 	<span class="comment">// rhs is a copy of the object</span></span><br><span class="line">&#123; 										<span class="comment">// passed in — note pass by val</span></span><br><span class="line">	<span class="built_in">swap</span>(rhs); 							<span class="comment">// swap *this’s data with</span></span><br><span class="line">										<span class="comment">// the copy’s</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用了两个特点：1拷贝赋值操作符参数可以不是引用；2利用参数传递的拷贝构造。</p>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ Make sure operator&#x3D; is well-behaved when an object is assigned to itself. Techniques include comparing addresses of source and target objects, careful statement ordering, and copy-and-swap.<br>✦ Make sure that any function operating on more than one object behaves correctly if two or more of the objects are the same.</p>
</blockquote>
<h2 id="item12-copy-all-part-of-an-object"><a href="#item12-copy-all-part-of-an-object" class="headerlink" title="item12:copy all part of an object"></a>item12:copy all part of an object</h2><p><em>copy function</em>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">logCall</span><span class="params">(<span class="type">const</span> std::string&amp; funcName)</span></span>; 			<span class="comment">// make a log entry</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs);</span><br><span class="line">	Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::<span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs)</span><br><span class="line">: <span class="built_in">name</span>(rhs.name) 									<span class="comment">// copy rhs’s data</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logCall</span>(<span class="string">&quot;Customer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logCall</span>(<span class="string">&quot;Customer copy assignment operator&quot;</span>);</span><br><span class="line">	name = rhs.name; 								<span class="comment">// copy rhs’s data</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>; 									<span class="comment">// see Item 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加另一个成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123; ... &#125;; 	<span class="comment">// for dates in time</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	... 				<span class="comment">// as before</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	Date lastTransaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原来的拷贝函数就是部分拷贝了。<br>下面的问题隐藏的更深：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123; 			<span class="comment">// a derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">	PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">: <span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">	priority = rhs.priority;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面没有拷贝基类的成员（会使用无参默认构造）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">: <span class="built_in">Customer</span>(rhs), 					<span class="comment">// invoke base class copy ctor</span></span><br><span class="line"><span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">	Customer::<span class="keyword">operator</span>=(rhs); 		<span class="comment">// assign base class parts</span></span><br><span class="line">	priority = rhs.priority;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ Copying functions should be sure to copy all of an object’s data members and all of its base class parts.<br>✦ Don’t try to implement one of the copying functions in terms of the other. Instead, put common functionality in a third function that<br>both call.</p>
</blockquote>
<h1 id="chap03-resource-management"><a href="#chap03-resource-management" class="headerlink" title="chap03: resource management"></a>chap03: resource management</h1><p>什么是resource？做完事后还给系统的资源！在c++中经常是动态分配内存！还有互斥锁，文件描述符，GUI的fonts&#x2F;brushes，数据库连接，网络socket等。手动管理很不现实！</p>
<h2 id="item13：use-objects-to-manage-resources"><a href="#item13：use-objects-to-manage-resources" class="headerlink" title="item13：use objects to manage resources."></a>item13：use objects to manage resources.</h2><p>投资建模：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; ... &#125;; 	<span class="comment">// root class of hierarchy of</span></span><br><span class="line">							<span class="comment">// investment types</span></span><br></pre></td></tr></table></figure>
<p>通过item7的<em>factory function</em>在库中提供<code>investment</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>; <span class="comment">// return ptr to dynamically allocated</span></span><br><span class="line">								<span class="comment">// object in the Investment hierarchy;</span></span><br><span class="line">								<span class="comment">// the caller must delete it</span></span><br><span class="line">								<span class="comment">// (parameters omitted for simplicity)</span></span><br></pre></td></tr></table></figure>
<p>如果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Investment *pInv = <span class="built_in">createInvestment</span>(); 	<span class="comment">// call factory function</span></span><br><span class="line">	... 									<span class="comment">// use pInv</span></span><br><span class="line">	<span class="keyword">delete</span> pInv; 							<span class="comment">// release object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数可能不能安全的释放资源。<br>下面使用<code>auto_ptr</code>来解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>; <span class="comment">// call factory</span></span><br><span class="line">														<span class="comment">// function</span></span><br><span class="line">	... 												<span class="comment">// use pInv as</span></span><br><span class="line">														<span class="comment">// before</span></span><br><span class="line">&#125; 														<span class="comment">// automatically</span></span><br><span class="line">														<span class="comment">// delete pInv via</span></span><br><span class="line">														<span class="comment">// auto_ptr’s dtor</span></span><br></pre></td></tr></table></figure>
<p>使用对象管理资源的两个至关重要的方面：</p>
<ul>
<li>Resources are acquired and immediately turned over to resource-managing objects.</li>
<li>Resource-managing objects use their destructors to ensure that resources are released（注意析构器中异常处理，见item8）</li>
</ul>
<p>不能两个<code>auto_ptr</code>指向同一个对象，所以拷贝（拷贝构造和拷贝赋值操作符）的语义很特别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::auto_ptr&lt;Investment&gt; 				<span class="comment">// pInv1 points to the</span></span><br><span class="line"><span class="built_in">pInv1</span>(<span class="built_in">createInvestment</span>()); 				<span class="comment">// object returned from</span></span><br><span class="line">										<span class="comment">// createInvestment</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv2</span><span class="params">(pInv1)</span></span>; <span class="comment">// pInv2 now points to the</span></span><br><span class="line">										<span class="comment">// object; pInv1 is now null</span></span><br><span class="line">pInv1 = pInv2; 							<span class="comment">// now pInv1 points to the</span></span><br><span class="line">										<span class="comment">// object, and pInv2 is null</span></span><br></pre></td></tr></table></figure>
<p>但是上面的语义也说明这不是一个很好的方式(<strong>不能用于STL容器</strong>）！</p>
<p>另一个选择是<em>reference-counting smart pointer</em>(RCSP),很像垃圾回收，但是不能打破循环引用！<br>TR1的<code>tr1::shared_ptr</code>(见item54)是一个RCSP:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">std::tr1::shared_ptr&lt;Investment&gt; 	<span class="comment">// pInv1 points to the</span></span><br><span class="line">		<span class="built_in">pInv1</span>(<span class="built_in">createInvestment</span>()); 	<span class="comment">// object returned from</span></span><br><span class="line">									<span class="comment">// createInvestment</span></span><br><span class="line">std::tr1::shared_ptr&lt;Investment&gt; 	<span class="comment">// both pInv1 and pInv2 now</span></span><br><span class="line"><span class="built_in">pInv2</span>(pInv1); 						<span class="comment">// point to the object</span></span><br><span class="line">pInv1 = pInv2; 						<span class="comment">// ditto — nothing has</span></span><br><span class="line">									<span class="comment">// changed ...</span></span><br><span class="line">&#125; 									<span class="comment">// pInv1 and pInv2 are</span></span><br><span class="line">									<span class="comment">// destroyed, and the</span></span><br><span class="line">									<span class="comment">// object they point to is</span></span><br><span class="line">									<span class="comment">// automatically deleted</span></span><br></pre></td></tr></table></figure>
<p>auto_ptr和tr1::shared_ptr都在析构函数中使用delete，<strong>而不是</strong>delete[]。不能动态分配数组，<strong>那该怎么办呢？</strong>，使用<code>vector</code>和<code>string</code>。</p>
<p>如果要定制自己的类需要注意item14和item15</p>
<p>在item18中看如何修改<code> createInvestment</code>接口！</p>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ To prevent resource leaks, use <code>RAII</code> objects that acquire resources in their constructors and release them in their destructors.<br>✦ Two commonly useful <code>RAII</code> classes are tr1::shared_ptr and auto_ptr. tr1::shared_ptr is usually the better choice, because its behavior when copied is intuitive. Copying an auto_ptr sets it to null.</p>
</blockquote>
<h2 id="item14-think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#item14-think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="item14: think carefully about copying behavior in resource-managing classes."></a>item14: think carefully about copying behavior in resource-managing classes.</h2><p>上面的两个指针对象是管理heap中资源的，有时候你可能要设计自己的资源管理类。<br>如互斥对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(Mutex *pm)</span></span>; 		<span class="comment">// lock mutex pointed to by pm</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(Mutex *pm)</span></span>; 	<span class="comment">// unlock the mutex</span></span><br></pre></td></tr></table></figure>
<p>设计类去管理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span></span></span><br><span class="line"><span class="function">	: mutexPtr(pm)</span></span><br><span class="line"><span class="function">	&#123;</span> <span class="built_in">lock</span>(mutexPtr); &#125; 			<span class="comment">// acquire resource</span></span><br><span class="line">	~<span class="built_in">Lock</span>() &#123; <span class="built_in">unlock</span>(mutexPtr); &#125; 	<span class="comment">// release resource</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用户可以如下使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mutex m; 		<span class="comment">// define the mutex you need to use</span></span><br><span class="line">...</span><br><span class="line">&#123; 				<span class="comment">// create block to define critical section</span></span><br><span class="line"><span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>; 	<span class="comment">// lock the mutex</span></span><br><span class="line">... 			<span class="comment">// perform critical section operations</span></span><br><span class="line">&#125; 				<span class="comment">// automatically unlock mutex at end</span></span><br><span class="line">				<span class="comment">// of block </span></span><br></pre></td></tr></table></figure>
<p>但是如果发生<strong>拷贝行为</strong>该怎么办？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>; 	<span class="comment">// lock m</span></span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(ml1)</span></span>; 	<span class="comment">// copy ml1 to ml2 — what should</span></span><br><span class="line">				<span class="comment">// happen here?</span></span><br></pre></td></tr></table></figure>
<p>你有<strong>多种选择</strong>：</p>
<ol>
<li>prohibit copying。详见item6</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>: <span class="keyword">private</span> Uncopyable &#123; 	<span class="comment">// prohibit copying — see</span></span><br><span class="line"><span class="keyword">public</span>: 							<span class="comment">// Item 6</span></span><br><span class="line">	... 							<span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在本例中<strong>适用</strong></p>
<ol start="2">
<li>reference-count the underlying resource。你可以内嵌<code>tr1::shared_ptr&lt;Mutex&gt;</code>，但是锁需要的是<strong>释放</strong>而不是删除。所以我们要更改默认的语义，定制<code>deleter</code>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span> 				<span class="comment">// init shared_ptr with the Mutex</span></span></span><br><span class="line"><span class="function">	: mutexPtr(pm, unlock) 					// to point to and the unlock func</span></span><br><span class="line"><span class="function">	&#123;</span> 										<span class="comment">// as the deleter†</span></span><br><span class="line">		<span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>()); 				<span class="comment">// see Item 15 for info on “get”</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr; 	<span class="comment">// use shared_ptr</span></span><br><span class="line">&#125;; 											<span class="comment">// instead of raw pointer</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>lock(mutexPtr.get())</code>的<code>get()</code>是什么？见item15</p>
</blockquote>
<p>不必声明析构器！</p>
<ol start="3">
<li>copy the underlying resource.</li>
<li>transfer ownership of the underlying resource.<code>auto_ptr</code>是一个例子。</li>
</ol>
<blockquote>
<p><strong>Things to Remember</strong>:<br>✦ Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.<br>✦ Common RAII class copying behaviors are disallowing copying and performing reference counting, but other behaviors are possible.</p>
</blockquote>
<h2 id="item15-provide-access-to-raw-resource-in-resource-managing-classes"><a href="#item15-provide-access-to-raw-resource-in-resource-managing-classes" class="headerlink" title="item15:provide access to raw resource in resource-managing classes."></a>item15:provide access to raw resource in resource-managing classes.</h2><p>有时候必须要使用一些老的API。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>; <span class="comment">// from Item 13</span></span><br></pre></td></tr></table></figure>
<p>假设你有函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">daysHeld</span><span class="params">(<span class="type">const</span> Investment *pi)</span></span>; <span class="comment">// return number of days</span></span><br><span class="line">									<span class="comment">// investment has been held</span></span><br></pre></td></tr></table></figure>
<p>你如果如下使用就会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>你有两种办法：显示转换和隐式转换</p>
<ul>
<li><strong>显式</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>()); <span class="comment">// fine, passes the raw pointer</span></span><br><span class="line"><span class="comment">// in pInv to daysHeld</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>隐式</strong>通过重载的<code>-&gt;</code>和<code>*</code>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; 									<span class="comment">// root class for a hierarchy</span></span><br><span class="line"><span class="keyword">public</span>: 											<span class="comment">// of investment types</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>; 					<span class="comment">// factory function</span></span><br><span class="line"></span><br><span class="line">std::tr1::shared_ptr&lt;Investment&gt; 					<span class="comment">// have tr1::shared_ptr</span></span><br><span class="line">	<span class="built_in">pi1</span>(<span class="built_in">createInvestment</span>()); 						<span class="comment">// manage a resource</span></span><br><span class="line">	</span><br><span class="line"><span class="type">bool</span> taxable1 = !(pi1-&gt;<span class="built_in">isTaxFree</span>()); 				<span class="comment">// access resource</span></span><br><span class="line">													<span class="comment">// via operator-&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pi2</span><span class="params">(createInvestment())</span></span>; 	<span class="comment">// have auto_ptr</span></span><br><span class="line">													<span class="comment">// manage a</span></span><br><span class="line">													<span class="comment">// resource</span></span><br><span class="line"><span class="type">bool</span> taxable2 = !((*pi2).<span class="built_in">isTaxFree</span>()); 				<span class="comment">// access resource</span></span><br><span class="line">													<span class="comment">// via operator* ...</span></span><br></pre></td></tr></table></figure>

<p>有时候你可能有一堆C API接口，如果你<strong>要使用这些接口</strong>必须使用<code>get()</code>这样的函数，这可能会很烦！比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>; 				<span class="comment">// from C API — params omitted</span></span><br><span class="line">									<span class="comment">// for simplicity</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>; 	<span class="comment">// from the same C API</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123; 						<span class="comment">// RAII class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span> 	<span class="comment">// acquire resource;</span></span></span><br><span class="line"><span class="function">	: f(fh) 						// use pass-by-value, because the</span></span><br><span class="line"><span class="function">	&#123;</span>&#125; 								<span class="comment">// C API does</span></span><br><span class="line">	~<span class="built_in">Font</span>() &#123; <span class="built_in">releaseFont</span>(f ); &#125; 	<span class="comment">// release resource</span></span><br><span class="line">	... 							<span class="comment">// handle copying (see Item 14)</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	FontHandle f; 					<span class="comment">// the raw font resource</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设有一个大型的与字体相关的C API完全处理<br><code>FontHandles</code>。<code>Font</code>类提供显式转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125; <span class="comment">// explicit conversion function</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你需要这样使用<code>get()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeFontSize</span><span class="params">(FontHandle f, <span class="type">int</span> newSize)</span></span>; <span class="comment">// from the C API</span></span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">changeFontSize</span>(f.<span class="built_in">get</span>(), newFontSize); 			<span class="comment">// explicitly convert</span></span><br><span class="line">												<span class="comment">// Font to FontHandle</span></span><br></pre></td></tr></table></figure>
<p>可以提供隐式的转换函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// implicit conversion function</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就可以像下面这样<strong>自然</strong>的使用这些C API了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">changeFontSize</span>(f, newFontSize); <span class="comment">// implicitly convert Font</span></span><br><span class="line">								<span class="comment">// to FontHandle</span></span><br></pre></td></tr></table></figure>
<p>但是也是有风险的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f1</span><span class="params">(getFont())</span></span>;</span><br><span class="line">...</span><br><span class="line">FontHandle f2 = f1; 	<span class="comment">// oops! meant to copy a Font</span></span><br><span class="line">						<span class="comment">// object, but instead implicitly</span></span><br><span class="line">						<span class="comment">// converted f1 into its underlying</span></span><br><span class="line">						<span class="comment">// FontHandle, then copied that</span></span><br></pre></td></tr></table></figure>
<p>上面的f1如果销毁，那么f2就是<strong>空悬指针</strong>！所以还是推荐用<code>get()</code></p>
<blockquote>
<p>Things to Remember<br>✦ APIs often require access to raw resources, so each RAII class should offer a way to get at the resource it manages.<br>✦ Access may be via explicit conversion or implicit conversion. In general, explicit conversion is safer, but implicit conversion is more convenient for clients</p>
</blockquote>
<h2 id="item16-use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#item16-use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="item16:use the same form in corresponding uses of new and delete."></a>item16:use the same form in corresponding uses of new and delete.</h2><p>使用new和delete的时候分别发生两件事！所以一个问题是delete的时候删除多少个对象！回答是有多少析构器被调用！（内置类型怎么办？）</p>
<p>注意<code>typedef</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>]; 		<span class="comment">// a person’s address has 4 lines,</span></span><br><span class="line">											<span class="comment">// each of which is a string</span></span><br><span class="line">std::string *pal = <span class="keyword">new</span> AddressLines;<span class="comment">// note that “new AddressLines”</span></span><br><span class="line">									<span class="comment">// returns a string*, just like</span></span><br><span class="line">									<span class="comment">// “new string[4]” would	</span></span><br><span class="line"><span class="keyword">delete</span> pal; 	<span class="comment">// undefined!</span></span><br><span class="line"><span class="keyword">delete</span> [] pal; 	<span class="comment">// fine							</span></span><br></pre></td></tr></table></figure>
<p>所以尽量不要对数组类型使用typedef！使用<code>vector</code>等STL</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ If you use [] in a new expression, you must use [] in the corresponding delete expression. If you don’t use [] in a new expression, you<br>mustn’t use [] in the corresponding delete expression.</p>
</blockquote>
<h2 id="item17-store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#item17-store-newed-objects-in-smart-pointers-in-standalone-statements" class="headerlink" title="item17:store newed objects in smart pointers in standalone statements."></a>item17:store newed objects in smart pointers in standalone statements.</h2><p>根据优先级处理Widget：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>假设：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
<p>上面的不会被编译！因为构造器是<code>explicit</code>！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
<p>但是上面的调用<strong>会导致内存泄漏</strong>！</p>
<p>假如按下列的顺序执行：</p>
<ol>
<li>Execute “new Widget”.</li>
<li>Call priority.</li>
<li>Call the tr1::shared_ptr constructor.</li>
</ol>
<p>如果调用<code>priority()</code>产生<strong>异常</strong>，那么资源就不会被分配到对象上。</p>
<blockquote>
<p>函数传参的语义是什么？理解上下两个方式的在传参上的区别！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; 	<span class="comment">// store newed object</span></span><br><span class="line">												<span class="comment">// in a smart pointer in a</span></span><br><span class="line">												<span class="comment">// standalone statement</span></span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>()); 					<span class="comment">// this call won’t leak</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Things to Remember<br>✦ Store newed objects in smart pointers in standalone statements.Failure to do this can lead to subtle resource leaks when exceptions<br>are thrown.</p>
</blockquote>
<h1 id="chap04-Designs-and-Declarations"><a href="#chap04-Designs-and-Declarations" class="headerlink" title="chap04:Designs and Declarations"></a>chap04:Designs and Declarations</h1><p>设计和声明好的c++接口！<br><strong>Guideline</strong>：they should be easy to use correctly and hard to use incorrectly.<br>依据上面的指导，我们讨论一系列话题：<br>correctness,efficiency,encapsulation,maintainability, extensibility, and conformance to convention.</p>
<h2 id="item18：make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><a href="#item18：make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly" class="headerlink" title="item18：make interfaces easy to use correctly and hard to use incorrectly."></a>item18：make interfaces easy to use correctly and hard to use incorrectly.</h2><p>函数接口，类接口，模板接口；<br>假设设计：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但上面的顺序很难让人把握：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> &#123; 			<span class="keyword">struct</span> <span class="title class_">Month</span> &#123; 				<span class="keyword">struct</span> <span class="title class_">Year</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span> 	<span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span> 		<span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">: val(d) &#123;</span>&#125; 			: <span class="built_in">val</span>(m) &#123;&#125; 				: <span class="built_in">val</span>(y)&#123;&#125;</span><br><span class="line"><span class="type">int</span> val; 				<span class="type">int</span> val; 					<span class="type">int</span> val;</span><br><span class="line">&#125;; 						&#125;; 							&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">const</span> Year&amp; y);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>)</span></span>; 						<span class="comment">// error! wrong types</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Day(<span class="number">30</span>), Month(<span class="number">3</span>), Year(<span class="number">1995</span>))</span></span>; 		<span class="comment">// error! wrong types</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>; 		<span class="comment">// okay, types are correct</span></span><br></pre></td></tr></table></figure>
<p>每年只有12个月，可以使用<code>enum</code>,但是这里不推荐使用！</p>
<blockquote>
<p>为什么不能使用<code>enum</code>？</p>
</blockquote>
<p>可以使用下面的技巧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>); &#125; 	<span class="comment">// functions returning all valid</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>); &#125; 	<span class="comment">// Month values; see below for</span></span><br><span class="line">	... 										<span class="comment">// why these are functions, not</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">12</span>); &#125; 	<span class="comment">// objects</span></span><br><span class="line">	... 										<span class="comment">// other member functions</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span></span>; 						<span class="comment">// prevent creation of new</span></span><br><span class="line">												<span class="comment">// Month values</span></span><br><span class="line">	... 										<span class="comment">// month-specific data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Mar(), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么使用函数而不是用对象！见item4</p>
</blockquote>
<p>加入const会避免手残，比如<code>*</code>的返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a * b = c) ... <span class="comment">// oops, meant to do a comparison!</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>unless there’s a good reason not to, have your types behave consistently with the built-in types</p>
</blockquote>
<p>size，count，length怎么选？</p>
<p>不要让客户记得做一些事情，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>; <span class="comment">// from Item 13; parameters omitted</span></span><br><span class="line">								<span class="comment">// for simplicity</span></span><br></pre></td></tr></table></figure>
<p>应该改成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果要设置特定的deleter的话：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	getRidOfInvestment)</span></span>;</span><br><span class="line">	... 					<span class="comment">// make retVal point to the</span></span><br><span class="line">							<span class="comment">// correct object</span></span><br><span class="line">	<span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>static_cast</code>详见item27，最好不要像上面这样先定义地址值为0的指针再赋值正确的指针值。见item26</p>
</blockquote>
<p>上面的deteter的定制可以避免cross-DLL问题。</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Good interfaces are easy to use correctly and hard to use incorrectly. You should strive for these characteristics in all your interfaces.<br>✦ Ways to facilitate correct use include consistency in interfaces and behavioral compatibility with built-in types.<br>✦ Ways to prevent errors include creating new types, restricting operations on types, constraining object values, and eliminating client resource management responsibilities.<br>✦ tr1::shared_ptr supports custom deleters. This prevents the crossDLL problem, can be used to automatically unlock mutexes (see Item 14), etc.</p>
</blockquote>
<h2 id="item19-treat-class-design-as-type-design"><a href="#item19-treat-class-design-as-type-design" class="headerlink" title="item19:treat class design as type design"></a>item19:treat class design as type design</h2><ul>
<li>How should objects of your new type be created and destroyed?</li>
<li>How should object initialization differ from object assignment?</li>
<li>What does it mean for objects of your new type to be passed by value?</li>
<li>What are the restrictions on legal values for your new type?</li>
<li>Does your new type fit into an inheritance graph?</li>
<li>What kind of type conversions are allowed for your new type?</li>
<li>What operators and functions make sense for the new type?</li>
<li>What standard functions should be disallowed?</li>
<li>Who should have access to the members of your new type?</li>
<li>What is the “undeclared interface” of your new type?</li>
<li>How general is your new type?</li>
<li>Is a new type really what you need?<blockquote>
<p><strong>Things to Remember</strong><br>✦ Class design is type design. Before defining a new type, be sure to consider all the issues discussed in this Item.</p>
</blockquote>
</li>
</ul>
<h2 id="item20-perfer-pass-by-reference-to-const-to-pass-by-value"><a href="#item20-perfer-pass-by-reference-to-const-to-pass-by-value" class="headerlink" title="item20:perfer pass-by-reference-to-const to pass-by-value."></a>item20:perfer pass-by-reference-to-const to pass-by-value.</h2><p>函数传参和返回通过copy constructor实现pass-by-value的，所以效率低。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(); 					<span class="comment">// parameters omitted for simplicity</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Person</span>(); 			<span class="comment">// see Item 7 for why this is virtual</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(); 					<span class="comment">// parameters again omitted</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Student</span>();</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string schoolName;</span><br><span class="line">	std::string schoolAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>; 		<span class="comment">// function taking a Student</span></span><br><span class="line">										<span class="comment">// by value</span></span><br><span class="line">Student plato; 							<span class="comment">// Plato studied under Socrates</span></span><br><span class="line"><span class="type">bool</span> platoIsOK = <span class="built_in">validateStudent</span>(plato);<span class="comment">// call the function</span></span><br></pre></td></tr></table></figure>
<p>如果如下声明就会避免这些问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>传引用可以避免<em>slicing problem</em>:即把派生类按值传递给基类。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>; 		<span class="comment">// return name of window</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>; 	<span class="comment">// draw window and contents</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你想多态的使用<code>display()</code>，那么下面的函数是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span> 	<span class="comment">// incorrect! parameter</span></span></span><br><span class="line"><span class="function"></span>&#123; 									<span class="comment">// may be sliced!</span></span><br><span class="line">std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="type">const</span> Window&amp; w)</span> 	<span class="comment">// fine, parameter won’t</span></span></span><br><span class="line"><span class="function"></span>&#123; 											<span class="comment">// be sliced</span></span><br><span class="line">std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是<strong>build-in类型</strong>还是pass-by-value更加的高效，因为引用就是用指针实现的！<strong>STL</strong>中的迭代器和函数对象也是pass-by-value设计的！</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Prefer pass-by-reference-to-const over pass-by-value. It’s typically more efficient and it avoids the slicing problem.<br>✦ The rule doesn’t apply to built-in types and STL iterator and function object types. For them, pass-by-value is usually appropriate.</p>
</blockquote>
<h2 id="item21-don’t-try-to-return-a-reference-when-you-must-return-an-object"><a href="#item21-don’t-try-to-return-a-reference-when-you-must-return-an-object" class="headerlink" title="item21:don’t try to return a reference when you must return an object."></a>item21:don’t try to return a reference when you must return an object.</h2><p>函数只能在stack和heap上创建新的对象，返回他们的引用会造成undefined behavior和内存泄漏。</p>
<p>天才的你可能使用下面的方案，返回一个<code>static</code>的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, 						<span class="comment">// warning! yet more</span></span><br><span class="line"><span class="type">const</span> Rational&amp; rhs) 		<span class="comment">// bad code!</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> Rational result; <span class="comment">// static object to which a</span></span><br><span class="line">							<span class="comment">// reference will be returned</span></span><br><span class="line">	result = ... ; 			<span class="comment">// multiply lhs by rhs and put the</span></span><br><span class="line">							<span class="comment">// product inside result</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是除了<strong>线程安全</strong>的问题，但是会有<strong>更深</strong>的缺点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Rational&amp; lhs, 	<span class="comment">// an operator==</span></span><br><span class="line">				<span class="type">const</span> Rational&amp; rhs); 	<span class="comment">// for Rationals</span></span><br><span class="line">Rational a, b, c, d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((a * b) == (c * d)) &#123;</span><br><span class="line">	<span class="keyword">do</span> whatever’s appropriate when the products are equal;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">do</span> whatever’s appropriate when they’re <span class="keyword">not</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Things to Remember</strong><br>✦ Never return a pointer or reference to a local stack object, a reference to a heap-allocated object, or a pointer or reference to a local static object if there is a chance that more than one such object will be needed. (Item 4 provides an example of a design where returning a reference to a local static is reasonable, at least in single-threaded environments.)</p>
</blockquote>
<h2 id="item22-declare-data-members-private"><a href="#item22-declare-data-members-private" class="headerlink" title="item22:declare data members private."></a>item22:declare data members private.</h2><p>通过函数设置多种访问权限：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getReadOnly</span><span class="params">()</span> <span class="type">const</span> 		</span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> value)</span> 	</span>&#123; readWrite = value; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getReadWrite</span><span class="params">()</span> <span class="type">const</span> 		</span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="type">int</span> value)</span> 	</span>&#123; writeOnly = value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> noAccess; 	<span class="comment">// no access to this int</span></span><br><span class="line">	<span class="type">int</span> readOnly; 	<span class="comment">// read-only access to this int</span></span><br><span class="line">	<span class="type">int</span> readWrite; 	<span class="comment">// read-write access to this int</span></span><br><span class="line">	<span class="type">int</span> writeOnly; 	<span class="comment">// write-only access to this int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还可以确保<em>encapsulation</em>，通过函数来进行不同的实现！不然很难进行不同的实现。public的东西后面很难去改！</p>
<p>从封装的观点来看： there are really only two access levels: private (which offers encapsulation) and everything else (which doesn’t).</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Declare data members private. It gives clients syntactically uniform access to data, affords fine-grained access control, allows invariants to be enforced, and offers class authors implementation flexibility.<br>✦ protected is no more encapsulated than public.</p>
</blockquote>
<h2 id="item23-prefer-non-member-non-friend-functions-to-member-functions"><a href="#item23-prefer-non-member-non-friend-functions-to-member-functions" class="headerlink" title="item23:prefer non-member non-friend functions to member functions."></a>item23:prefer non-member non-friend functions to member functions.</h2><p>假设web浏览器提供了三种清除功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果想全部清除，下面的实现哪个好？<br><strong>成员函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>; <span class="comment">// calls clearCache, clearHistory,</span></span><br><span class="line">							<span class="comment">// and removeCookies</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>非成员函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	wb.<span class="built_in">clearCache</span>();</span><br><span class="line">	wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">	wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装就是让更少的能够接触数据，如果成员函数和非成员非友元函数的功能一致，选非成员非友元的！</p>
<p>需要注意的是非成员函数并不代表不能是其他类的成员！（有些语言所有的函数都要放在类里，如java，c#），我们可以把<code>clearBrowser()</code>放到一些utility类并声明成static，这样就可以<strong>不创建</strong>类实例的使用！</p>
<p>在c++中有更加合适的办法，使用<code>namespace</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>namespaces可以跨多个文件，所以可以拆分<em>convenient function</em>到多个文件，你可以根据兴趣包含对应的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header “webbrowser.h” — header for class WebBrowser itself</span></span><br><span class="line"><span class="comment">// as well as “core” WebBrowser-related functionality</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">	... 								<span class="comment">// “core” related functionality, e.g.</span></span><br><span class="line">										<span class="comment">// non-member functions almost</span></span><br><span class="line">										<span class="comment">// all clients need</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// header “webbrowserbookmarks.h”</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">	... 								<span class="comment">// bookmark-related convenience</span></span><br><span class="line">&#125; 										<span class="comment">// functions</span></span><br><span class="line"><span class="comment">// header “webbrowsercookies.h”</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">	... 								<span class="comment">// cookie-related convenience</span></span><br><span class="line">&#125; 										<span class="comment">// functions</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面的也是标准库的组织方式！这也意味着拓展性！</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Prefer non-member non-friend functions to member functions. Doing so increases encapsulation, packaging flexibility, and functional extensibility</p>
</blockquote>
<h2 id="item24-declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><a href="#item24-declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters" class="headerlink" title="item24:declare non-member functions when type conversions should apply to all parameters."></a>item24:declare non-member functions when type conversions should apply to all parameters.</h2><p>虽然隐式的类型转换是坏主意，但是也有例外，比如int到有理数的转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="comment">// ctor is deliberately not explicit;</span></span><br><span class="line">	<span class="type">int</span> denominator = <span class="number">1</span>); 		<span class="comment">// allows implicit int-to-Rational</span></span><br><span class="line">								<span class="comment">// conversions</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>; 		<span class="comment">// accessors for numerator and</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>; 	<span class="comment">// denominator — see Item 22</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果把<code>operator *</code>声明成成员函数如何？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果如下使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEighth; 	<span class="comment">// fine</span></span><br><span class="line">result = result * oneEighth; 			<span class="comment">// fine</span></span><br></pre></td></tr></table></figure>
<p>但是你想混合运算就会出错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">// fine</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个会出现隐式的转换！所以前面声明构造器的时候没有写explicit.</p>
</blockquote>
<p>只有在参数列表的时候才会发生隐式的转换！所以上面的第二个调用发生了error。可以实现下面的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">	... 										<span class="comment">// contains no operator*</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, 	<span class="comment">// now a non-member</span></span><br><span class="line"><span class="type">const</span> Rational&amp; rhs) 							<span class="comment">// function</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">	lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>; 						<span class="comment">// fine</span></span><br><span class="line">result = <span class="number">2</span> * oneFourth; 						<span class="comment">// hooray, it works!</span></span><br></pre></td></tr></table></figure>

<p>还有一个问题，<code>operator*</code>是否声明为友元？在这个例子中不需要，因为public接口就能完成任务。</p>
<blockquote>
<p>成员函数的对立面是非成员函数，不是friend function。就像数据成员分成private和non-private。</p>
</blockquote>
<blockquote>
<p>OO转变成模板设计的Rational见item46</p>
</blockquote>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ If you need type conversions on all parameters to a function (including the one that would otherwise be pointed to by the this pointer), the function must be a non-member. </p>
</blockquote>
<h2 id="item25-consider-support-for-a-non-throwing-swap"><a href="#item25-consider-support-for-a-non-throwing-swap" class="headerlink" title="item25:consider support for a non-throwing swap."></a>item25:consider support for a non-throwing swap.</h2><p><code>swap()</code>是exception-safe编程的支柱！<br>经典实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 	<span class="comment">// typical implementation of std::swap;</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> 	<span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来没什么了不起的，但是如果一些类型主要包含指针去指向真实的data，（常见于“pimpl idiom”即pointer to implementation)。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123; 			<span class="comment">// class for Widget data;</span></span><br><span class="line"><span class="keyword">public</span>: 					<span class="comment">// details are unimportant</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a, b, c; 			<span class="comment">// possibly lots of data —</span></span><br><span class="line">	std::vector&lt;<span class="type">double</span>&gt; v; 	<span class="comment">// expensive to copy!</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用pimpl idiom：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; 							<span class="comment">// class using the pimpl idiom</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">// to copy a Widget, copy its</span></span><br><span class="line">	&#123; 									<span class="comment">// WidgetImpl object. For </span></span><br><span class="line">		... 							<span class="comment">// details on implementing</span></span><br><span class="line">		*pImpl = *(rhs.pImpl); 			<span class="comment">// operator= in general, </span></span><br><span class="line">		... 							<span class="comment">// see Items 10, 11, and 12. </span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	WidgetImpl *pImpl; 					<span class="comment">// ptr to object with this</span></span><br><span class="line">&#125;; 										<span class="comment">// Widget’s data</span></span><br></pre></td></tr></table></figure>
<p>如果要高效的实现交换只需要交换指针就行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt; 						<span class="comment">// this is a specialized version</span></span><br><span class="line">	<span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, 	<span class="comment">// of std::swap for when T is</span></span><br><span class="line">	Widget&amp; b) 						<span class="comment">// Widget</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(a.pImpl, b.pImpl); 	<span class="comment">// to swap Widgets, swap their</span></span><br><span class="line">	&#125; 								<span class="comment">// pImpl pointers; this won’t compile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面的不会编译，因为指针是private的，可以声明friend，但是更加传统的实现是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; 						<span class="comment">// same as above, except for the</span></span><br><span class="line"><span class="keyword">public</span>: 							<span class="comment">// addition of the swap mem func</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> std::swap; 			<span class="comment">// the need for this declaration</span></span><br><span class="line">									<span class="comment">// is explained later in this Item</span></span><br><span class="line">		<span class="built_in">swap</span>(pImpl, other.pImpl); 	<span class="comment">// to swap Widgets, swap their</span></span><br><span class="line">	&#125; 								<span class="comment">// pImpl pointers</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt; 						<span class="comment">// revised specialization of</span></span><br><span class="line">	<span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, 	<span class="comment">// std::swap</span></span><br><span class="line">	Widget&amp; b)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">swap</span>(b); 					<span class="comment">// to swap Widgets, call their</span></span><br><span class="line">	&#125; 								<span class="comment">// swap member function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果都是<code>Widget</code>和<code>Widgetimpl</code>都是<strong>模板类</strong>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>你可能写下下面illegal的语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="type">void</span> swap&lt;Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a, <span class="comment">// error! illegal code!</span></span><br><span class="line">	Widget&lt;T&gt;&amp; b)</span><br><span class="line">	&#123; a.<span class="built_in">swap</span>(b); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么上面有错误？为什么函数模板不支持部分特化，而类模板支持？</p>
</blockquote>
<p>通常的做法是重载<code>swap()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 	<span class="comment">// an overloading of std::swap</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, <span class="comment">// (note the lack of “&lt;...&gt;” after</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Widget&lt;T&gt;&amp; b)</span> 			<span class="comment">// “swap”), but see below for</span></span></span><br><span class="line"><span class="function">	</span>&#123; a.<span class="built_in">swap</span>(b); &#125; 			<span class="comment">// why this isn’t valid code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然理论上是可以的，但是<code>std</code>是一个<strong>特殊的</strong>namespace，完全专门化模板是可以的，但是不允许新加模板，类，函数等等！</p>
<p>有了一个全新的解决方案（非成员的解决方案）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">	... 					<span class="comment">// templatized WidgetImpl, etc.</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 	<span class="comment">// as before, including the swap</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;; 	<span class="comment">// member function</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 	<span class="comment">// non-member swap function;</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, <span class="comment">// not part of the std namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a.<span class="built_in">swap</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候不要指定<code>swap()</code>的哪个实例，而是如下的让编译器自动寻找最匹配的并把<code>std</code><strong>做保底</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::swap; 	<span class="comment">// make std::swap available in this function</span></span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">swap</span>(obj1, obj2); 	<span class="comment">// call the best swap for objects of type T</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后永远不要让<code>swap()</code>抛出异常,针对的是<strong>成员版本</strong>。item29会说明为什么。</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Provide a swap member function when std::swap would be inefficient for your type. Make sure your swap doesn’t throw exceptions.<br>✦ If you offer a member swap, also offer a non-member swap that calls the member. For classes (not templates), specialize std::swap, too.<br>✦ When calling swap, employ a using declaration for std::swap, then call swap without namespace qualification.<br>✦ It’s fine to totally specialize std templates for user-defined types, but never try to add something completely new to std.</p>
</blockquote>
<h1 id="chap05：Implementations"><a href="#chap05：Implementations" class="headerlink" title="chap05：Implementations"></a>chap05：Implementations</h1><h2 id="item26：postpone-variable-definitions-as-long-as-possible"><a href="#item26：postpone-variable-definitions-as-long-as-possible" class="headerlink" title="item26：postpone variable definitions as long as possible."></a>item26：postpone variable definitions as long as possible.</h2><p>ctor&#x2F;dtor的使用使得未使用的类型也会有损耗。有时候无法避免：</p>
<p>尽量使用拷贝构造！</p>
<p>循环方式A，析构次数少，但是B的可维护性，可理解性更高，应该<strong>默认选B</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop 		// Approach B: define inside loop</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; 			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">	w = some value dependent on i; 			<span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;</span><br><span class="line">... 									...</span><br><span class="line">&#125; 										&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Postpone variable definitions as long as possible. It increases program clarity and improves program efficiency.</p>
</blockquote>
<h2 id="item27-minimize-casting"><a href="#item27-minimize-casting" class="headerlink" title="item27:minimize casting"></a>item27:minimize casting</h2><p>有三种形式的cast：<br>前两种是old-style风格：c-style和function-style</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T) expression <span class="comment">// cast expression to be of type T</span></span><br><span class="line"><span class="built_in">T</span>(expression) <span class="comment">// cast expression to be of type T</span></span><br></pre></td></tr></table></figure>
<p>还有new-style或者c++-style casts:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure>
<p>只在传递给构造器才使用old-style了不用new-style：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>)); 			<span class="comment">// create Widget from int</span></span><br><span class="line">									<span class="comment">// with function-style cast</span></span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">									<span class="comment">// with C++-style cast</span></span><br></pre></td></tr></table></figure>
<p>下面是常见的错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; 								<span class="comment">// base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123; ... &#125; 		<span class="comment">// base onResize impl</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123; 		<span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123; 				<span class="comment">// derived onResize impl;</span></span><br><span class="line">	<span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>(); 	<span class="comment">// cast *this to Window,</span></span><br><span class="line">											<span class="comment">// then call its onResize;</span></span><br><span class="line">											<span class="comment">// this doesn’t work!</span></span><br><span class="line">	... 									<span class="comment">// do SpecialWindow-</span></span><br><span class="line">	&#125; 										<span class="comment">// specific stuff</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>学过inside c++ object model理解上面这个应该就很简单了。</p>
</blockquote>
<p>上面的cast并不能调用<code>Window::onResize()</code>(懂得都懂）。<br>解决方案是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Window::<span class="built_in">onResize</span>(); <span class="comment">// call Window::onResize</span></span><br><span class="line">		... 				<span class="comment">// on *this</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面也提示了，使用cast可能是发生错误的信号，如果能不用就不用。</p>
</blockquote>
<p><code>dynamic_cast</code>的实现是相当slow的！</p>
<p>两种方法避免使用<code>dynamic_cast</code>。<br>先看本来的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">blink</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> 											<span class="comment">// see Item 13 for info</span></span><br><span class="line">	std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW; <span class="comment">// on tr1::shared_ptr</span></span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPW::iterator iter = winPtrs.<span class="built_in">begin</span>(); 		<span class="comment">// undesirable code:</span></span><br><span class="line">		iter != winPtrs.<span class="built_in">end</span>(); 							<span class="comment">// uses dynamic_cast</span></span><br><span class="line">		++iter) &#123;</span><br><span class="line">					<span class="keyword">if</span> (SpecialWindow *psw = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;(iter-&gt;<span class="built_in">get</span>()))</span><br><span class="line">					psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>(); 	<span class="comment">// better code: uses</span></span><br><span class="line">		iter != winPtrs.<span class="built_in">end</span>(); 					<span class="comment">// no dynamic_cast</span></span><br><span class="line">		++iter)</span><br><span class="line">	(*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure>
<p>或者尽量的声明虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123;&#125; 				<span class="comment">// default impl is no-op;</span></span><br><span class="line">	... 									<span class="comment">// see Item 34 for why</span></span><br><span class="line">&#125;; 											<span class="comment">// a default impl may be</span></span><br><span class="line">											<span class="comment">// a bad idea</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; ... &#125; 			<span class="comment">// in this class, blink</span></span><br><span class="line">	... 									<span class="comment">// does something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs; 								<span class="comment">// container holds</span></span><br><span class="line">											<span class="comment">// (ptrs to) all possible</span></span><br><span class="line">... 										<span class="comment">// Window types</span></span><br><span class="line"><span class="keyword">for</span> (VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();</span><br><span class="line">	iter != winPtrs.<span class="built_in">end</span>();</span><br><span class="line">	++iter) 								<span class="comment">// note lack of</span></span><br><span class="line">	(*iter)-&gt;<span class="built_in">blink</span>(); 							<span class="comment">// dynamic_cast</span></span><br></pre></td></tr></table></figure>
<p>下面的使用方式要极力的避免！丑陋且不宜维护：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; ... &#125;;</span><br><span class="line">... 												<span class="comment">// derived classes are defined here</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPW::iterator iter = winPtrs.<span class="built_in">begin</span>(); iter != winPtrs.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SpecialWindow1 *psw1 =</span><br><span class="line">			<span class="built_in">dynamic_cast</span>&lt;SpecialWindow1*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (SpecialWindow2 *psw2 =</span><br><span class="line">			<span class="built_in">dynamic_cast</span>&lt;SpecialWindow2*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (SpecialWindow3 *psw3 =</span><br><span class="line">			<span class="built_in">dynamic_cast</span>&lt;SpecialWindow3*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Things to Remember</strong><br>✦ Avoid casts whenever practical, especially dynamic_casts in performance-sensitive code. If a design requires casting, try to develop a cast-free alternative.<br>✦ When casting is necessary, try to hide it inside a function. Clients can then call the function instead of putting casts in their own code.<br>✦ Prefer C++-style casts to old-style casts. They are easier to see, and they are more specific about what they do.</p>
</blockquote>
<h2 id="item28：avoid-returning-“handles”-to-object-internals"><a href="#item28：avoid-returning-“handles”-to-object-internals" class="headerlink" title="item28：avoid returning “handles” to object internals."></a>item28：avoid returning “handles” to object internals.</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; 				<span class="comment">// class for representing points</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123; 		<span class="comment">// Point data for a Rectangle</span></span><br><span class="line">	Point ulhc; 		<span class="comment">// ulhc = “ upper left-hand corner”</span></span><br><span class="line">	Point lrhc; 		<span class="comment">// lrhc = “ lower right-hand corner”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::tr1::shared_ptr&lt;RectData&gt; pData; 	<span class="comment">// see Item 13 for info on</span></span><br><span class="line">&#125;; 											<span class="comment">// tr1::shared_ptr</span></span><br></pre></td></tr></table></figure>
<p>如果获得左上和右下的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">	<span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面就会出现一个使const对象改变值的自我矛盾！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>; 	<span class="comment">// rec is a const rectangle from</span></span><br><span class="line">										<span class="comment">// (0, 0) to (100, 100)</span></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>); 				<span class="comment">// now rec goes from</span></span><br><span class="line">										<span class="comment">// (50, 0) to (100, 100)!</span></span><br></pre></td></tr></table></figure>

<p>可以采取下面的办法防止出现问题（返回const的引用）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这又会导致<em>dangling handles</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rectangle 					<span class="comment">// returns a rectangle by</span></span><br><span class="line"><span class="built_in">boundingBox</span>(<span class="type">const</span> GUIObject&amp; obj); 	<span class="comment">// value; see Item 3 for why</span></span><br><span class="line">									<span class="comment">// return type is const</span></span><br></pre></td></tr></table></figure>
<p>用户会这么使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GUIObject *pgo; 					<span class="comment">// make pgo point to</span></span><br><span class="line">... 								<span class="comment">// some GUIObject</span></span><br><span class="line"><span class="type">const</span> Point *pUpperLeft = 			<span class="comment">// get a ptr to the upper</span></span><br><span class="line"> &amp;(<span class="built_in">boundingBox</span>(*pgo).<span class="built_in">upperLeft</span>()); 	<span class="comment">// left point of its</span></span><br><span class="line">									<span class="comment">// bounding box</span></span><br></pre></td></tr></table></figure>
<p>就会导致上面的问题。</p>
<blockquote>
<p>如果返回对象而不是handles会解决这个问题吗？</p>
</blockquote>
<p>但有些例外必须要返回引用（这些都有明确的生命期）如<code>operator[]</code>。</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Avoid returning handles (references, pointers, or iterators) to object internals. Not returning handles increases encapsulation, helps const member functions act const, and minimizes the creation of dangling handles.</p>
</blockquote>
<h2 id="item29-strive-for-exception-safe-code"><a href="#item29-strive-for-exception-safe-code" class="headerlink" title="item29:strive for exception-safe code."></a>item29:strive for exception-safe code.</h2><p>考虑下面的有背景图片的GUI menus：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>; 			<span class="comment">// change background</span></span><br><span class="line">	... 			<span class="comment">// image</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Mutex mutex; 		<span class="comment">// mutex for this object</span></span><br><span class="line">Image *bgImage; 	<span class="comment">// current background image</span></span><br><span class="line"><span class="type">int</span> imageChanges; 	<span class="comment">// # of times image has been changed</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">lock</span>(&amp;mutex); 				<span class="comment">// acquire mutex (as in Item 14)</span></span><br><span class="line">	<span class="keyword">delete</span> bgImage; 			<span class="comment">// get rid of old background</span></span><br><span class="line">	++imageChanges; 			<span class="comment">// update image change count</span></span><br><span class="line">	bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);<span class="comment">// install new background</span></span><br><span class="line">	<span class="built_in">unlock</span>(&amp;mutex); 			<span class="comment">// release mutex</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的函数<code>changeBackground()</code>是很差的，而exception-safe要求：</p>
<ul>
<li>leak no resources.</li>
<li>don’t allow data structures to become corrupted.</li>
</ul>
<p>第一个好解决使用item14用对象管理mutex：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>; 	<span class="comment">// from Item 14: acquire mutex and</span></span><br><span class="line">						<span class="comment">// ensure its later release</span></span><br><span class="line">	<span class="keyword">delete</span> bgImage;</span><br><span class="line">	++imageChanges;</span><br><span class="line">	bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个怎么解决呢？先介绍三个术语,exception-safe function 提供其中之一的保证：</p>
<ul>
<li>the basic guarantee</li>
<li>the strong guarantee</li>
<li>the nothrow guarantee：所有的操作都使用<strong>内置类型</strong></li>
</ul>
<blockquote>
<p><code>int doSomething() throw(); // note empty exception spec</code><br>什么意思？<code>throw()</code></p>
</blockquote>
<p>下面我们为函数提供strong guarantee：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	std::tr1::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">	bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc)); 	<span class="comment">// replace bgImage’s internal</span></span><br><span class="line">										<span class="comment">// pointer with the result of the</span></span><br><span class="line">										<span class="comment">// “new Image” expression</span></span><br><span class="line">	++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了<strong>智能指针</strong>和<strong>语句重拍</strong>。<br>但是还有问题，如果<code>imgsrc</code>构造器出现exception，那么上述的也只能提供基本保证！</p>
<p>上面的先放在一边，先学习一个strong guarantee的<strong>通用策略</strong><em>copy and swap</em>. swap是non-throwing的（见item25）</p>
<p>介绍<strong>经典</strong>的实现：<br>先实现”pimpl idiom”(item31介绍了）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123; 										<span class="comment">// PMImpl = “PrettyMenu</span></span><br><span class="line">	std::tr1::shared_ptr&lt;Image&gt; bgImage; 				<span class="comment">// Impl.”; see below for</span></span><br><span class="line">	<span class="type">int</span> imageChanges; 									<span class="comment">// why it’s a struct</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mutex mutex;</span><br><span class="line">	std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::swap; 									<span class="comment">// see Item 25</span></span><br><span class="line">	<span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>; 									<span class="comment">// acquire the mutex</span></span><br><span class="line">	std::tr1::shared_ptr&lt;PMImpl&gt; 						<span class="comment">// copy obj. data</span></span><br><span class="line">			<span class="built_in">pNew</span>(<span class="keyword">new</span> <span class="built_in">PMImpl</span>(*pImpl));</span><br><span class="line">	pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc)); 			<span class="comment">// modify the copy</span></span><br><span class="line">	++pNew-&gt;imageChanges;</span><br><span class="line">	<span class="built_in">swap</span>(pImpl, pNew); 									<span class="comment">// swap the new</span></span><br><span class="line">														<span class="comment">// data into place</span></span><br><span class="line">&#125; 														<span class="comment">// release the mutex</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的pimpl idiom值得学习，注意拷贝语义！</p>
</blockquote>
<p>上面并不能保证所有整个函数都是strongly exception-safe,比如调用了其他函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	... <span class="comment">// make copy of local state</span></span><br><span class="line">	<span class="built_in">f1</span>();</span><br><span class="line">	<span class="built_in">f2</span>();</span><br><span class="line">	... <span class="comment">// swap modified state into place</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>即便</strong>f1和f2都是strongly exception-safe，如果发f1执行完了，执行f2的时候出现了异常。。。。</p>
<p>copy and swap的效率并不是很好</p>
<blockquote>
<p>Things to Remember<br>✦ Exception-safe functions leak no resources and allow no data structures to become corrupted, even when exceptions are thrown. Such functions offer the basic, strong, or nothrow guarantees.<br>✦ The strong guarantee can often be implemented via copy-and-swap,but the strong guarantee is not practical for all functions.<br>✦ A function can usually offer a guarantee no stronger than the weakest guarantee of the functions it calls.</p>
</blockquote>
<h2 id="item30-understand-the-ins-and-outs-of-inlining"><a href="#item30-understand-the-ins-and-outs-of-inlining" class="headerlink" title="item30:understand the ins and outs of inlining."></a>item30:understand the ins and outs of inlining.</h2><p>声明<code>inline</code>对编译器来说是request,不是command。分为显式声明和隐式声明。</p>
<p>inline函数应该在头文件。模板也必须在头文件内！（不同的编译器可能不同）</p>
<p>inline函数的指针调用不会inline</p>
<p>ctor和dtor不会inline（编译器会插入很多东西）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string bm1, bm2; 		<span class="comment">// base members 1 and 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>() &#123;&#125; 				<span class="comment">// Derived’s ctor is empty — or is it?</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string dm1, dm2, dm3; 	<span class="comment">// derived members 1–3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Derived()</code>可能是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() 						<span class="comment">// conceptual implementation of</span></span><br><span class="line">&#123; 										<span class="comment">// “empty” Derived ctor</span></span><br><span class="line">	Base::<span class="built_in">Base</span>(); 						<span class="comment">// initialize Base part</span></span><br><span class="line">	<span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125; 	<span class="comment">// try to construct dm1</span></span><br><span class="line">	<span class="built_in">catch</span> (...) &#123; 						<span class="comment">// if it throws,</span></span><br><span class="line">		Base::~<span class="built_in">Base</span>(); 					<span class="comment">// destroy base class part and</span></span><br><span class="line">		<span class="keyword">throw</span>; 							<span class="comment">// propagate the exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125; 	<span class="comment">// try to construct dm2</span></span><br><span class="line">	<span class="built_in">catch</span>(...) &#123; 						<span class="comment">// if it throws,</span></span><br><span class="line">		dm1.std::string::~<span class="built_in">string</span>(); 	<span class="comment">// destroy dm1,</span></span><br><span class="line">		Base::~<span class="built_in">Base</span>(); 					<span class="comment">// destroy base class part, and</span></span><br><span class="line">		<span class="keyword">throw</span>; 							<span class="comment">// propagate the exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125; 	<span class="comment">// construct dm3</span></span><br><span class="line">	<span class="built_in">catch</span>(...) &#123; 						<span class="comment">// if it throws,</span></span><br><span class="line">		dm2.std::string::~<span class="built_in">string</span>(); 	<span class="comment">// destroy dm2,</span></span><br><span class="line">		dm1.std::string::~<span class="built_in">string</span>(); 	<span class="comment">// destroy dm1,</span></span><br><span class="line">		Base::~<span class="built_in">Base</span>(); 					<span class="comment">// destroy base class part, and</span></span><br><span class="line">		<span class="keyword">throw</span>; 							<span class="comment">// propagate the exception</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Limit most inlining to small, frequently called functions. This facilitates debugging and binary upgradability, minimizes potential code bloat, and maximizes the chances of greater program speed.<br>✦ Don’t declare function templates inline just because they appear in header files.</p>
</blockquote>
<h2 id="item31-Minimize-compliation-dependence-between-files"><a href="#item31-Minimize-compliation-dependence-between-files" class="headerlink" title="item31:Minimize compliation dependence between files."></a>item31:Minimize compliation dependence between files.</h2><p>小小的改变需要recompile &amp;relink,这是因为接口和实现不能完全的分离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">	<span class="type">const</span> Address&amp; addr);</span><br><span class="line">	<span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string theName; 	<span class="comment">// implementation detail</span></span><br><span class="line">	Date theBirthDate; 		<span class="comment">// implementation detail</span></span><br><span class="line">	Address theAddress; 	<span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么不是只定义接口呢，只有接口变了再重新编译？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">string</span>; 				<span class="comment">// forward declaration (an incorrect</span></span><br><span class="line">&#125; 								<span class="comment">// one — see below)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; 					<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>; 					<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">	<span class="type">const</span> Address&amp; addr);</span><br><span class="line">	<span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先因为前向声明的不确定性，其次编译器要知道对象的大小来分配空间。<br>可以用下面的两个类来实现一定程度的实现分离：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> 	<span class="comment">// standard library components</span></span></span><br><span class="line">					<span class="comment">// shouldn’t be forward-declared</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> 	<span class="comment">// for tr1::shared_ptr; see below</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>; 	<span class="comment">// forward decl of Person impl. class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; 		<span class="comment">// forward decls of classes used in</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>; 		<span class="comment">// Person interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">	<span class="type">const</span> Address&amp; addr);</span><br><span class="line">	<span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>: 									<span class="comment">// ptr to implementation;</span></span><br><span class="line">	std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl; <span class="comment">// see Item 13 for info on</span></span><br><span class="line">&#125;; 											<span class="comment">// std::tr1::shared_ptr</span></span><br></pre></td></tr></table></figure>

<p>上面的分离的关键是把定义的依赖替换成声明的依赖。</p>
<ul>
<li>Avoid using objects when object references and pointers will do.</li>
<li>Depend on class declarations instead of class definitions whenever you can.</li>
</ul>
<p>函数的定义不需要类定义只需要类声明就行！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; 					<span class="comment">// class declaration</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>; 					<span class="comment">// fine — no definition</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>; <span class="comment">// of Date is needed</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Provide separate header files for declarations and definitions.</li>
</ul>
<p>下面是实现使用pimpl idiom(也被成为<strong>handle class</strong>）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span> 					<span class="comment">// we’re implementing the Person class,</span></span></span><br><span class="line">										<span class="comment">// so we must #include its class definition</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span> 				<span class="comment">// we must also #include PersonImpl’s class</span></span></span><br><span class="line">										<span class="comment">// definition, otherwise we couldn’t call</span></span><br><span class="line">										<span class="comment">// its member functions; note that</span></span><br><span class="line">										<span class="comment">// PersonImpl has exactly the same public</span></span><br><span class="line">										<span class="comment">// member functions as Person — their</span></span><br><span class="line">										<span class="comment">// interfaces are identical</span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr)</span><br><span class="line">: <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PersonImpl</span>(name, birthday, addr))</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种实现handle class的方法是interface class（特定的虚基类）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有纯虚函数的类不能实例化！所以必须提供factory function给派生类实例化虚基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="type">static</span> std::tr1::shared_ptr&lt;Person&gt; 	<span class="comment">// return a tr1::shared_ptr to a new</span></span><br><span class="line">		<span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name, 	<span class="comment">// Person initialized with the</span></span><br><span class="line">				<span class="type">const</span> Date&amp; birthday, 		<span class="comment">// given params; see Item 18 for</span></span><br><span class="line">				<span class="type">const</span> Address&amp; addr); 		<span class="comment">// why a tr1::shared_ptr is returned ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户可以如下的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// create an object supporting the Person interface</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout 	&lt;&lt; pp-&gt;<span class="built_in">name</span>() 			<span class="comment">// use the object via the</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot; was born on &quot;</span> 		<span class="comment">// Person interface</span></span><br><span class="line">			&lt;&lt; pp-&gt;<span class="built_in">birthDate</span>()</span><br><span class="line">			&lt;&lt; <span class="string">&quot; and now lives at &quot;</span></span><br><span class="line">			&lt;&lt; pp-&gt;<span class="built_in">address</span>();</span><br><span class="line">			... 					<span class="comment">// the object is automatically</span></span><br><span class="line">									<span class="comment">// deleted when pp goes out of</span></span><br><span class="line">									<span class="comment">// scope — see Item 13</span></span><br></pre></td></tr></table></figure>

<p>所以背后是如何实现的？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">	<span class="type">const</span> Address&amp; addr)</span><br><span class="line">	: <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">	<span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>; 			<span class="comment">// implementations of these</span></span><br><span class="line">	<span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>; 		<span class="comment">// functions are not shown, but</span></span><br><span class="line">	<span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>; 		<span class="comment">// they are easy to imagine</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string theName;</span><br><span class="line">	Date theBirthDate;</span><br><span class="line">	Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Person::create</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>( name, birthday,</span><br><span class="line">addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RealPerson</code>阐述了两个实现接口类的机制：</p>
<ol>
<li>继承接口，实现接口</li>
<li>再多继承中实现接口（见item40）</li>
</ol>
<p>handle class和interface class都能实现接口和实现解耦，进而减少编译依赖。</p>
<blockquote>
<p>犬儒主义，看穿。即花费是什么？</p>
</blockquote>
<p>handle class增加了indirection，interface class也增加indirection。</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ The general idea behind minimizing compilation dependencies is to depend on declarations instead of definitions. Two approaches<br>based on this idea are Handle classes and Interface classes.<br>✦ Library header files should exist in full and declaration-only forms. This applies regardless of whether templates are involved.</p>
</blockquote>
<h1 id="chap06-Inheritance-and-Object-Oriented-Design"><a href="#chap06-Inheritance-and-Object-Oriented-Design" class="headerlink" title="chap06:Inheritance and Object-Oriented Design"></a>chap06:Inheritance and Object-Oriented Design</h1><h2 id="item32-Make-sure-public-inheritance-models”is-a”"><a href="#item32-Make-sure-public-inheritance-models”is-a”" class="headerlink" title="item32:Make sure public inheritance models”is-a”."></a>item32:Make sure public inheritance models”is-a”.</h2><blockquote>
<p><strong>Things to Remember</strong><br>✦ Public inheritance means “is-a.” Everything that applies to base classes must also apply to derived classes, because every derived class object is a base class object.</p>
</blockquote>
<h2 id="item33-avoid-hiding-inherited-names"><a href="#item33-avoid-hiding-inherited-names" class="headerlink" title="item33:avoid hiding inherited names."></a>item33:avoid hiding inherited names.</h2><p>模板继承的name hiding的问题见item43</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Names in derived classes hide names in base classes. Under public inheritance, this is never desirable.<br>✦ To make hidden names visible again, employ using declarations or forwarding functions.</p>
</blockquote>
<h2 id="Item-34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><a href="#Item-34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation" class="headerlink" title="Item 34: Differentiate between inheritance of interface and inheritance of implementation."></a>Item 34: Differentiate between inheritance of interface and inheritance of implementation.</h2><p>public继承可以细分为inheritance of function interfaces &amp; inheriance of function implementations。</p>
<p>到底是继承接口还是继承实现？override实现或者直接继承实现？</p>
<p>下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>纯虚函数</strong>的目的是继承接口（纯虚函数也可以定义，但是使用的时候要用类名）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Shape; <span class="comment">// error! Shape is abstract</span></span><br><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle; <span class="comment">// fine</span></span><br><span class="line">ps1-&gt;<span class="built_in">draw</span>(); <span class="comment">// calls Rectangle::draw</span></span><br><span class="line">Shape *ps2 = <span class="keyword">new</span> Ellipse; <span class="comment">// fine</span></span><br><span class="line">ps2-&gt;<span class="built_in">draw</span>(); <span class="comment">// calls Ellipse::draw</span></span><br><span class="line">ps1-&gt;Shape::<span class="built_in">draw</span>(); <span class="comment">// calls Shape::draw</span></span><br><span class="line">ps2-&gt;Shape::<span class="built_in">draw</span>(); <span class="comment">// calls Shape::draw</span></span><br></pre></td></tr></table></figure>

<p><strong>虚函数</strong>的目的继承接口和default实现。<br>但是继承default实现会出现问题（会让你不经意的使用）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airport</span> &#123; ... &#125;; <span class="comment">// represents airports</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">default</span> code <span class="keyword">for</span> flying an airplane to the given destination</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span>: <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span>: <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>如果着急着上线新飞机，但新飞机有不同的<code>fly()</code>忘记override了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelC</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">... <span class="comment">// no fly function is declared</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Airport <span class="title">PDX</span><span class="params">(...)</span></span>; <span class="comment">// PDX is the airport near my home</span></span><br><span class="line">Airplane *pa = <span class="keyword">new</span> ModelC;</span><br><span class="line">...</span><br><span class="line">pa-&gt;<span class="built_in">fly</span>(PDX); <span class="comment">// calls Airplane::fly!</span></span><br></pre></td></tr></table></figure>
<p>就会造成灾难！一个可行的方法是（声明为纯虚，添加<code>protected</code>的<code>defaultFly()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defaultFly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">default</span> code <span class="keyword">for</span> flying an airplane to the given destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="built_in">defaultFly</span>(destination); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="built_in">defaultFly</span>(destination); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelC</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	code <span class="keyword">for</span> flying a ModelC airplane to the given destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在定义虚函数的时候要思考如果派生类没有覆写怎么办？</p>
</blockquote>
<p>上面的解决方案也有缺点，函数名的激增，故而提供了另一种解决方法（融合了<code>fly()</code>和<code>defaultFly()</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span> <span class="comment">// an implementation of</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// a pure virtual function</span></span><br><span class="line">	<span class="keyword">default</span> code <span class="keyword">for</span> flying an airplane to</span><br><span class="line">	the given destination</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">	</span>&#123; Airplane::<span class="built_in">fly</span>(destination); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">	</span>&#123; Airplane::<span class="built_in">fly</span>(destination); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelC</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	code <span class="keyword">for</span> flying a ModelC airplane to the given destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非虚函数的目的是继承接口和<strong>强制</strong>实现！</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Inheritance of interface is different from inheritance of implementation. Under public inheritance, derived classes always inherit base class interfaces.<br>✦ Pure virtual functions specify inheritance of interface only.<br>✦ Simple (impure) virtual functions specify inheritance of interface plus inheritance of a default implementation.<br>✦ Non-virtual functions specify inheritance of interface plus inheritance of a mandatory implementation.</p>
</blockquote>
<h2 id="item35-consider-alternatives-to-virtual-functions"><a href="#item35-consider-alternatives-to-virtual-functions" class="headerlink" title="item35:consider alternatives to virtual functions."></a>item35:consider alternatives to virtual functions.</h2><p>游戏设计：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return character’s health rating;</span></span><br><span class="line">	... <span class="comment">// derived classes may redefine this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>The Template Method Pattern via the Non-Virtual Interface Idiom</strong></p>
<p>一个古老的流派：所有的虚函数都应该是private的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> 			<span class="comment">// derived classes do not redefine</span></span></span><br><span class="line"><span class="function">	</span>&#123; 									<span class="comment">// this — see Item 36</span></span><br><span class="line">		... 							<span class="comment">// do “before” stuff — see below</span></span><br><span class="line">		<span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>(); 	<span class="comment">// do the real work</span></span><br><span class="line">		... 							<span class="comment">// do “after” stuff — see below</span></span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span> 	<span class="comment">// derived classes may redefine this</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		... 							<span class="comment">// default algorithm for calculating</span></span><br><span class="line">	&#125; 									<span class="comment">// character’s health</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是non-virtual interface（NVI）idiom。也可以说非虚函数是虚函数的warpper。</p>
<p>NVI保证了调用虚函数的时候有正确的上下文（context）！比如在”before”  stuff之前上锁等等。</p>
<blockquote>
<p>你最好不要让客户直接调用虚函数！</p>
</blockquote>
<blockquote>
<p>access-level，在基类虚函数声明为private，在派生类能够声明成public吗？</p>
</blockquote>
<p><strong>The Strategy Pattern via Function Pointers</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// forward declaration</span></span><br><span class="line"><span class="comment">// function for the default health calculation algorithm</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">	: healthFunc(hcf )</span></span><br><span class="line"><span class="function">	&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>不同的实例可以有不同的函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">	: GameCharacter(hcf )</span></span><br><span class="line"><span class="function">	&#123;</span> ... &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// health calculation</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// funcs with different</span></span><br><span class="line"><span class="comment">// behavior</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>; <span class="comment">// same-type characEvilBadGuy ebg2(loseHealthSlowly); // ters with different</span></span><br><span class="line"><span class="comment">// health-related</span></span><br><span class="line"><span class="comment">// behavior</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用指针可以在<strong>运行时</strong>改变指针值（即改变函数）</li>
</ul>
<p>注意函数指针调用的函数无法访问non-public的类成员。如果使用友元和public accessor函数（这些函数可能更希望hidden）可能或多或少的破坏封装。</p>
<p><strong>The Strategy Pattern via tr1::function</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>; <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// HealthCalcFunc is any callable entity that can be called with</span></span><br><span class="line">	<span class="comment">// anything compatible with a GameCharacter and that returns anything</span></span><br><span class="line">	<span class="comment">// compatible with an int; see below for details</span></span><br><span class="line">	<span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">	: healthFunc(hcf )</span></span><br><span class="line"><span class="function">	&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：<br><code>std::tr1::function&lt;int (const GameCharacter&amp;)&gt;</code><br>客户使用的时候就有了惊人的灵活性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">short</span> <span class="title">calcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>; 		<span class="comment">// health calculation</span></span><br><span class="line">												<span class="comment">// function; note</span></span><br><span class="line">												<span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> &#123; 						<span class="comment">// class for health</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span> 	<span class="comment">// calculation function</span></span></span><br><span class="line"><span class="function">	</span>&#123; ... &#125; 									<span class="comment">// objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span></span>; 	<span class="comment">// health calculation </span></span><br><span class="line">	... 										<span class="comment">// mem function; note</span></span><br><span class="line">&#125;; 												<span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123; 		<span class="comment">// as before</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EyeCandyCharacter</span>: <span class="keyword">public</span> GameCharacter &#123; <span class="comment">// another character</span></span><br><span class="line">	... 									<span class="comment">// type; assume same</span></span><br><span class="line">&#125;; 											<span class="comment">// constructor as</span></span><br><span class="line">											<span class="comment">// EvilBadGuy</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>; 				<span class="comment">// character using a</span></span><br><span class="line">											<span class="comment">// health calculation</span></span><br><span class="line">											<span class="comment">// function</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>; <span class="comment">// character using a</span></span><br><span class="line">											<span class="comment">// health calculation</span></span><br><span class="line">											<span class="comment">// function object</span></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( 							<span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function">	std::tr1::bind(&amp;GameLevel::health, 		<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">					currentLevel, 			<span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">					_1) 					<span class="comment">// see below for details</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>The “Classic” Strategy Pattern</strong><br>更加合适的设计是把health-calculation函数设置在health-calculation继承关系中的虚函数：<br><img src="https://img-blog.csdnimg.cn/ed6b84018e52438a86e9d811a8fe2348.png" alt="在这里插入图片描述"><br>下面是代码阐述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; ... &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">	: pHealthCalc(phcf)</span></span><br><span class="line"><span class="function">	&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HealthCalcFunc *pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结：<br>■ Use the <strong>non-virtual interface idiom</strong> (NVI idiom), a form of the Template Method design pattern that wraps public non-virtual member functions around less accessible virtual functions.<br>■ Replace virtual functions with <strong>function pointer data members</strong>, a stripped-down manifestation of the Strategy design pattern.<br>■ Replace virtual functions with <strong>tr1::function data members</strong>, thus allowing use of any callable entity with a signature compatible with what you need. This, too, is a form of the Strategy design pattern.<br>■ Replace virtual functions in one hierarchy with <strong>virtual functions in another hierarchy</strong>. This is the conventional implementation of the Strategy design pattern.</p>
<blockquote>
<p>Things to Remember<br>✦ Alternatives to virtual functions include the NVI idiom and various forms of the Strategy design pattern. The NVI idiom is itself an example of the Template Method design pattern.<br>✦ A disadvantage of moving functionality from a member function to a function outside the class is that the non-member function lacks access to the class’s non-public members.<br>✦ tr1::function objects act like generalized function pointers. Such objects support all callable entities compatible with a given target signature.</p>
</blockquote>
<h2 id="item36-never-redefine-an-inherited-non-virtual-function"><a href="#item36-never-redefine-an-inherited-non-virtual-function" class="headerlink" title="item36:never redefine an inherited non-virtual function."></a>item36:never redefine an inherited non-virtual function.</h2><blockquote>
<p>Things to Remember<br>✦ Never redefine an inherited non-virtual function.</p>
</blockquote>
<h2 id="item37-never-redefine-a-function’s-inherited-default-parameter-value"><a href="#item37-never-redefine-a-function’s-inherited-default-parameter-value" class="headerlink" title="item37:never redefine a function’s inherited default parameter value."></a>item37:never redefine a function’s inherited default parameter value.</h2><p><em>virtual functions are dynamically bound, but defaultparameter values are statically bound.</em></p>
<p>出于性能的需要，才做出了这样奇怪的设计！</p>
<p>使用NVI idiom解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span> <span class="comment">// now non-virtual</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="built_in">doDraw</span>(color); <span class="comment">// calls a virtual</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// the actual work is</span></span><br><span class="line">&#125;; <span class="comment">// done in this func</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>; <span class="comment">// note lack of a</span></span><br><span class="line">	... <span class="comment">// default param val.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Things to Remember<br>✦ Never redefine an inherited default parameter value, because default parameter values are statically bound, while virtual functions — the only functions you should be redefining — are dynamically bound.</p>
</blockquote>
<h2 id="Item-38-Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition"><a href="#Item-38-Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition" class="headerlink" title="Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition."></a>Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition.</h2><p><em>application domain</em>和<em>implementation domain</em></p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Composition has meanings completely different from that of public inheritance.<br>✦ In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.</p>
</blockquote>
<h2 id="item39-use-private-inheritance-judiciously"><a href="#item39-use-private-inheritance-judiciously" class="headerlink" title="item39:use private inheritance judiciously."></a>item39:use private inheritance judiciously.</h2><p><em>private inheritance means that implementation only should be inherited; interface should be ignored.</em></p>
<p>If D privately inherits from B, it means that D objects are implemented <strong>in terms of</strong> B objects.<br>所以这里的in-terms-of和item38中<strong>composition</strong>是什么关系？——-能compose就compose,然后才是private inherited。</p>
<p>假若有<code>Widget</code>类，我们想追踪成员函数的调用次数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>; 		<span class="comment">// automatically called for each tick</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>让<code>Widget</code>public继承是肯定不对的，所以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// look at Widget usage data, etc.</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果我们也可以使用composition（很复杂）：<br><img src="https://img-blog.csdnimg.cn/00ab16bb72b14d149db0e79389d74e7f.png" alt="在这里插入图片描述"><br>但是我们还是更喜欢public继承+composition（给出了两点理由）。</p>
<p>但是还是有一些edge case！比如<strong>空类</strong>（没有非静态数据成员，没有虚函数和虚基类）</p>
<blockquote>
<p><strong>Things to Remember</strong><br>✦ Private inheritance means is-implemented-in-terms of. It’s usually inferior to composition, but it makes sense when a derived class<br>needs access to protected base class members or needs to redefine inherited virtual functions.<br>✦ Unlike composition, private inheritance can enable the empty base optimization. This can be important for library developers who strive<br>to minimize object sizes.</p>
</blockquote>
<h2 id="Item-40-Use-multiple-inheritance-judiciously"><a href="#Item-40-Use-multiple-inheritance-judiciously" class="headerlink" title="Item 40: Use multiple inheritance judiciously."></a>Item 40: Use multiple inheritance judiciously.</h2><p>关于MI的讨论分为两派。</p>
<p>首先是多继承会有命名冲突：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowableItem</span> &#123; <span class="comment">// something a library lets you borrow</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">checkOut</span><span class="params">()</span></span>; <span class="comment">// check the item out from the library</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// perform self-test, return whether</span></span><br><span class="line">	... <span class="comment">// test succeeds</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span>: <span class="comment">// note MI here</span></span><br><span class="line">	<span class="keyword">public</span> BorrowableItem, <span class="comment">// (some libraries loan MP3 players)</span></span><br><span class="line">	<span class="keyword">public</span> ElectronicGadget</span><br><span class="line">&#123; ... &#125;; <span class="comment">// class definition is unimportant</span></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.<span class="built_in">checkOut</span>(); <span class="comment">// ambiguous! which checkOut?</span></span><br></pre></td></tr></table></figure>
<p>虽然两个函数的accessibility是不一样的，一个是public，一个是private的；<strong>但是先检查名字，再检查accessible。</strong></p>
<p>为了消除ambiguity：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.BorrowableItem::<span class="built_in">checkOut</span>(); <span class="comment">// ah, that checkOut...</span></span><br></pre></td></tr></table></figure>

<p>还有一个严重的问题：<br><img src="https://img-blog.csdnimg.cn/493a5b9032eb40e2b06375778fc4ca5d.png" alt="在这里插入图片描述"><br>重复还是不重复c++没有立场，它只是提供了另一种选择：<br><img src="https://img-blog.csdnimg.cn/7d656ff20f184fe18c2f2773451c1461.png" alt="在这里插入图片描述"></p>
<p>从理论上说public继承永远都是virtual。所以public继承<strong>都</strong>声明成虚的。<strong>但是</strong>正确性不是唯一的要求！虚继承很复杂！</p>
<p>所以有两个建议：</p>
<ol>
<li>尽量不要使用虚基类</li>
<li>如果必须使用虚基类，不要放置数据。</li>
</ol>
<p>下面我们用下面的接口类去建模person</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>IPerson</code>的用户不能实例化，需要用factory function去实例化派生类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factory function to create a Person object from a unique database ID;</span></span><br><span class="line"><span class="comment">// see Item 18 for why the return type isn’t a raw pointer</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;IPerson&gt; <span class="title">makePerson</span><span class="params">(DatabaseID personIdentifier)</span></span>;</span><br><span class="line"><span class="comment">// function to get a database ID from the user</span></span><br><span class="line"><span class="function">DatabaseID <span class="title">askUserForDatabaseID</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DatabaseID <span class="title">id</span><span class="params">(askUserForDatabaseID())</span></span>;</span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;IPerson&gt; <span class="title">pp</span><span class="params">(makePerson(id))</span></span>; <span class="comment">// create an object</span></span><br><span class="line"><span class="comment">// supporting the</span></span><br><span class="line"><span class="comment">// IPerson interface</span></span><br><span class="line">... <span class="comment">// manipulate *pp via</span></span><br><span class="line"><span class="comment">// IPerson’s member</span></span><br><span class="line"><span class="comment">// functions</span></span><br></pre></td></tr></table></figure>
<p>如何使得<code>makePerson()</code>返回指针呢？我们需要创建一个派生类<code>CPerson</code>你可以重新去写这个类，也可以从已有的类<code>PersonInfo</code>去拓展：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">theName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">theBirthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// see</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">valueDelimClose</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// below</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一些实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">PersonInfo::valueDelimOpen</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;[&quot;</span>; <span class="comment">// default opening delimiter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">PersonInfo::valueDelimClose</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;]&quot;</span>; <span class="comment">// default closing delimiter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">PersonInfo::theName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// reserve buffer for return value; because this is</span></span><br><span class="line">	<span class="comment">// static, it’s automatically initialized to all zeros</span></span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> value[Max_Formatted_Field_Value_Length];</span><br><span class="line">	<span class="comment">// write opening delimiter</span></span><br><span class="line">	std::<span class="built_in">strcpy</span>(value, <span class="built_in">valueDelimOpen</span>());</span><br><span class="line">	append to the string in value <span class="keyword">this</span> object’<span class="function">s name <span class="title">field</span> <span class="params">(being careful</span></span></span><br><span class="line"><span class="params"><span class="function">	to avoid buffer overruns!)</span></span></span><br><span class="line"><span class="function">	<span class="comment">// write closing delimiter</span></span></span><br><span class="line"><span class="function">	<span class="title">std::strcat</span><span class="params">(value, valueDelimClose())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>valueDelimOpen</code>和 <code>valueDelimClose</code>都是虚函数，那么你就可以在派生类中改写你的返回规则，如：“Homer”, not “[Homer]”.</p>
<p><code>CPerson</code>和<code>PersonInfo</code>的关系是is-implemented-in-terms-of。可以使用composition或者private继承。在这里要<strong>改写虚函数</strong>，故选择继承。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IPerson</span> &#123; <span class="comment">// this class specifies the</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// interface to be implemented</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseID</span> &#123; ... &#125;; <span class="comment">// used below; details are</span></span><br><span class="line"><span class="comment">// unimportant</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonInfo</span> &#123; <span class="comment">// this class has functions</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// useful in implementing</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>; <span class="comment">// the IPerson interface</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">theName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">theBirthDate</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">valueDelimClose</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPerson</span>: <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123; <span class="comment">// note use of MI</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">CPerson</span><span class="params">(DatabaseID pid)</span>: PersonInfo(pid) &#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// implementations</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> PersonInfo::<span class="built_in">theName</span>(); &#125; <span class="comment">// of the required</span></span><br><span class="line">	<span class="comment">// IPerson member</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// functions</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> PersonInfo::<span class="built_in">theBirthDate</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// redefinitions of</span></span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125; <span class="comment">// inherited virtual</span></span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">valueDelimClose</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125; <span class="comment">// delimiter</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的关系如下（UML）：<br><img src="https://img-blog.csdnimg.cn/1b5d10bab42e4d31abd9a0d2fa6d67ec.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Things to Remember<br>✦ Multiple inheritance is more complex than single inheritance. It can lead to new ambiguity issues and to the need for virtual inheritance.<br>✦ Virtual inheritance imposes costs in size, speed, and complexity of initialization and assignment. It’s most practical when virtual base classes have no data.<br>✦ Multiple inheritance does have legitimate uses. One scenario involves combining public inheritance from an Interface class with private inheritance from a class that helps with implementation.</p>
</blockquote>
<h1 id="chap07-Templates-and-Generic-Programming"><a href="#chap07-Templates-and-Generic-Programming" class="headerlink" title="chap07:Templates and Generic Programming"></a>chap07:Templates and Generic Programming</h1><p><strong>generic programming</strong> — the ability to write code that is independent of the types of objects being manipulated.</p>
<p>c++的模板机制是图灵完全的：<strong>template metaprogramming</strong>: the creation of programs that execute inside C++ compilers and that stop running when compilation is complete</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/myblog/tags/cpp/" rel="tag"># cpp</a>
              <a href="/myblog/tags/effective-c/" rel="tag"># effective c++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/myblog/2023/09/04/OpenGl%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/" rel="prev" title="OpenGL模型加载">
      <i class="fa fa-chevron-left"></i> OpenGL模型加载
    </a></div>
      <div class="post-nav-item">
    <a href="/myblog/2023/09/05/%E9%AB%98%E7%BA%A7OpenGl/" rel="next" title="高级OpenGL">
      高级OpenGL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.1.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E4%B9%A0%E6%83%AF"><span class="nav-number">1.2.</span> <span class="nav-text">命名习惯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%80%83%E8%99%91"><span class="nav-number">1.3.</span> <span class="nav-text">对多线程的考虑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TR1-and-Boost"><span class="nav-number">1.4.</span> <span class="nav-text">TR1 and Boost</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chap01%EF%BC%9Aaccustoming-yourself-to-c"><span class="nav-number">2.</span> <span class="nav-text">chap01：accustoming yourself  to c++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#item1%EF%BC%9Aview-C-as-a-federation-of-languages"><span class="nav-number">2.1.</span> <span class="nav-text">item1：view C++ as a federation of languages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item2-perfer-consts-enums-and-inlines-to-defines"><span class="nav-number">2.2.</span> <span class="nav-text">Item2:perfer consts,enums,and inlines to #defines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item3%EF%BC%9Ause-const-whenever-possible"><span class="nav-number">2.3.</span> <span class="nav-text">Item3：use const whenever possible.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item4-make-sure-that-object-are-initialized-before-they%E2%80%99re-used"><span class="nav-number">2.4.</span> <span class="nav-text">item4:make sure that object are initialized before they’re used</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chap02-ctor-dtor-and-assignment-operators"><span class="nav-number">3.</span> <span class="nav-text">chap02:ctor,dtor,and assignment operators</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#item3%EF%BC%9Akonw-what-functions-c-silently-writes-and-calls"><span class="nav-number">3.1.</span> <span class="nav-text">item3：konw what functions c++ silently writes and calls.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item6-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><span class="nav-number">3.2.</span> <span class="nav-text">item6:explicitly disallow the use of compiler-generated functions you do not want.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item7-declare-dtors-virtual-in-polymorphic-base-classes"><span class="nav-number">3.3.</span> <span class="nav-text">item7:declare dtors virtual in polymorphic base classes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item8%EF%BC%9Aprevent-exceptions-from-leaving-dtor"><span class="nav-number">3.4.</span> <span class="nav-text">item8：prevent exceptions from leaving dtor.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item9-never-call-virtual-functions-during-ctor-or-dtor"><span class="nav-number">3.5.</span> <span class="nav-text">item9:never call virtual functions during ctor or dtor.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item10-have-assignment-operators-return-a-reference-to-this"><span class="nav-number">3.6.</span> <span class="nav-text">item10:have assignment operators return a reference to *this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item11-handle-assignment-to-self-in-operator"><span class="nav-number">3.7.</span> <span class="nav-text">item11: handle assignment to self in operator&#x3D;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item12-copy-all-part-of-an-object"><span class="nav-number">3.8.</span> <span class="nav-text">item12:copy all part of an object</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chap03-resource-management"><span class="nav-number">4.</span> <span class="nav-text">chap03: resource management</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#item13%EF%BC%9Ause-objects-to-manage-resources"><span class="nav-number">4.1.</span> <span class="nav-text">item13：use objects to manage resources.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item14-think-carefully-about-copying-behavior-in-resource-managing-classes"><span class="nav-number">4.2.</span> <span class="nav-text">item14: think carefully about copying behavior in resource-managing classes.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item15-provide-access-to-raw-resource-in-resource-managing-classes"><span class="nav-number">4.3.</span> <span class="nav-text">item15:provide access to raw resource in resource-managing classes.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item16-use-the-same-form-in-corresponding-uses-of-new-and-delete"><span class="nav-number">4.4.</span> <span class="nav-text">item16:use the same form in corresponding uses of new and delete.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item17-store-newed-objects-in-smart-pointers-in-standalone-statements"><span class="nav-number">4.5.</span> <span class="nav-text">item17:store newed objects in smart pointers in standalone statements.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chap04-Designs-and-Declarations"><span class="nav-number">5.</span> <span class="nav-text">chap04:Designs and Declarations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#item18%EF%BC%9Amake-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><span class="nav-number">5.1.</span> <span class="nav-text">item18：make interfaces easy to use correctly and hard to use incorrectly.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item19-treat-class-design-as-type-design"><span class="nav-number">5.2.</span> <span class="nav-text">item19:treat class design as type design</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item20-perfer-pass-by-reference-to-const-to-pass-by-value"><span class="nav-number">5.3.</span> <span class="nav-text">item20:perfer pass-by-reference-to-const to pass-by-value.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item21-don%E2%80%99t-try-to-return-a-reference-when-you-must-return-an-object"><span class="nav-number">5.4.</span> <span class="nav-text">item21:don’t try to return a reference when you must return an object.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item22-declare-data-members-private"><span class="nav-number">5.5.</span> <span class="nav-text">item22:declare data members private.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item23-prefer-non-member-non-friend-functions-to-member-functions"><span class="nav-number">5.6.</span> <span class="nav-text">item23:prefer non-member non-friend functions to member functions.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item24-declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><span class="nav-number">5.7.</span> <span class="nav-text">item24:declare non-member functions when type conversions should apply to all parameters.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item25-consider-support-for-a-non-throwing-swap"><span class="nav-number">5.8.</span> <span class="nav-text">item25:consider support for a non-throwing swap.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chap05%EF%BC%9AImplementations"><span class="nav-number">6.</span> <span class="nav-text">chap05：Implementations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#item26%EF%BC%9Apostpone-variable-definitions-as-long-as-possible"><span class="nav-number">6.1.</span> <span class="nav-text">item26：postpone variable definitions as long as possible.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item27-minimize-casting"><span class="nav-number">6.2.</span> <span class="nav-text">item27:minimize casting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item28%EF%BC%9Aavoid-returning-%E2%80%9Chandles%E2%80%9D-to-object-internals"><span class="nav-number">6.3.</span> <span class="nav-text">item28：avoid returning “handles” to object internals.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item29-strive-for-exception-safe-code"><span class="nav-number">6.4.</span> <span class="nav-text">item29:strive for exception-safe code.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item30-understand-the-ins-and-outs-of-inlining"><span class="nav-number">6.5.</span> <span class="nav-text">item30:understand the ins and outs of inlining.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item31-Minimize-compliation-dependence-between-files"><span class="nav-number">6.6.</span> <span class="nav-text">item31:Minimize compliation dependence between files.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chap06-Inheritance-and-Object-Oriented-Design"><span class="nav-number">7.</span> <span class="nav-text">chap06:Inheritance and Object-Oriented Design</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#item32-Make-sure-public-inheritance-models%E2%80%9Dis-a%E2%80%9D"><span class="nav-number">7.1.</span> <span class="nav-text">item32:Make sure public inheritance models”is-a”.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item33-avoid-hiding-inherited-names"><span class="nav-number">7.2.</span> <span class="nav-text">item33:avoid hiding inherited names.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><span class="nav-number">7.3.</span> <span class="nav-text">Item 34: Differentiate between inheritance of interface and inheritance of implementation.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item35-consider-alternatives-to-virtual-functions"><span class="nav-number">7.4.</span> <span class="nav-text">item35:consider alternatives to virtual functions.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item36-never-redefine-an-inherited-non-virtual-function"><span class="nav-number">7.5.</span> <span class="nav-text">item36:never redefine an inherited non-virtual function.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item37-never-redefine-a-function%E2%80%99s-inherited-default-parameter-value"><span class="nav-number">7.6.</span> <span class="nav-text">item37:never redefine a function’s inherited default parameter value.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-38-Model-%E2%80%9Chas-a%E2%80%9D-or-%E2%80%9Cis-implemented-in-terms-of%E2%80%9D-through-composition"><span class="nav-number">7.7.</span> <span class="nav-text">Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item39-use-private-inheritance-judiciously"><span class="nav-number">7.8.</span> <span class="nav-text">item39:use private inheritance judiciously.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-40-Use-multiple-inheritance-judiciously"><span class="nav-number">7.9.</span> <span class="nav-text">Item 40: Use multiple inheritance judiciously.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chap07-Templates-and-Generic-Programming"><span class="nav-number">8.</span> <span class="nav-text">chap07:Templates and Generic Programming</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jxWu"
      src="/myblog/uploads/myimage.jpg">
  <p class="site-author-name" itemprop="name">jxWu</p>
  <div class="site-description" itemprop="description">record and up</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/myblog/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/myblog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/myblog/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jxWu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/myblog/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/myblog/lib/anime.min.js"></script>
  <script src="/myblog/lib/velocity/velocity.min.js"></script>
  <script src="/myblog/lib/velocity/velocity.ui.min.js"></script>

<script src="/myblog/js/utils.js"></script>

<script src="/myblog/js/motion.js"></script>


<script src="/myblog/js/schemes/pisces.js"></script>


<script src="/myblog/js/next-boot.js"></script>


  <script defer src="/myblog/lib/three/three.min.js"></script>
    <script defer src="/myblog/lib/three/three-waves.min.js"></script>
    <script defer src="/myblog/lib/three/canvas_lines.min.js"></script>
    <script defer src="/myblog/lib/three/canvas_sphere.min.js"></script>


  















  

  

</body>
</html>
