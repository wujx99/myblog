---
title: jyyos代码导读和课程记录
date: 2023-09-27 11:51:23
tags:
- 操作系统
- jyyos
---
代码阅读见github
# lecture01
# lecture02
# lecture03

## firmware
硬件与程序员的约定

状态机的初始状态，有cpu reset的状态和firmware加载后的状态。这个程序模拟了firmware加载了我们的代码，然后我们自己用类似系统调用的方式调用fireware的代码。我们使用qemu来模拟这个加载过程，并且qemu是可以**调试**的，使用gdb监听local host来调试。并且展示了`init.gdb`的调试技巧还有watch point的技巧来帮助简化流程。见`Makefile`文件的详解。

## hello-os
直接在计算机硬件上运行hello world程序。

但是我们需要很多框架代码和库。可以看提供实验的代码和框架（比较复杂）
我们`am.h`中的api只有简单的几个，但是我们却可以真正的在操作系统运行起来

`kernel.c`是一个50行的操作系统


tips：
1. vscode如何配置补全和宏，配置`compile_commands.json`,使用`bear -- make`就可以生成
2. `$(AM_HOME)/Makefile`是很难读的，这时候就要想一下该如何处理--->转换成状态机，观察执行时的状态去理解。而**不是**只看状态机的描述！使用`make -nB`命令打印make执行状态而不执行
3. `make -nB`输出的结果并不好读，但是用unix哲学和改善文本的可读性来说实现。然后用Ai等的的工具，就可以获得比较好读的.
{% asset_img img01.png %}
然后就可以看到命令的执行的过程，一些编译选项**定义的宏**，配置的`include`的路径等信息都一清二楚。
4. 可以看到磁盘镜像时怎么生成的
{% asset_img img02.png %}

# lecture04

## model
利用python的generator的特性去实现。
重要的是`os-model.py`的这一行
```python os-model.py
for syscall in OperatingSystem.SYSCALLS:
        src = src.replace(f'sys_{syscall}',        # sys_write(...)
                          f'yield "{syscall}", ')  #  -> yield 'write', (...)

```
`os-real.h`是对应的真实的c语言的实现

tips
1. 在程序开始前和结束后，执行一些代码的trick(避免提前的return，导致main靠后的释放资源的代码不能执行)
```c os-real.h
// Constructor called before main()
static inline void __attribute__((constructor))
srand_init() {
  srand(time(0));
}

// Destructor called after main()
static inline void __attribute__((destructor))
thread_join() {
  for (int i = 0; i < nthreads; i++) {
    pthread_join(threads[i], NULL);  // Wait for thread terminations
  }
}
```


## mosaic
500行建模操作系统，一个更加完善的模型。可以输出程序运行的状态图。

所有的不确定性都来自于系统调用，所以我们就可以数出所有的运行的可能性。

# lecture05

## hello
除了我们在课件上的用python建模的部分，我们还可以在真实的os上实现这样的并发程序

## stack-probe
每个线程都有自己独立的堆栈，如何确立独立堆栈的大小？
我们通过这个例程得到了8192kb大小。但是该如何配置这个大小呢？

tips
1. 下面的是什么意思？
```c stack-probe.c
setbuf(stdout, NULL);
```
控制缓冲区，使得程序crash的时候还能打印。后面操作系统的课会给详细的解释

## alipay

展示原子性

## sum

也是展示原子性的例子，但是可以更加的极端，把`sum ++`改成一条汇编指令
```c sum.c
asm volatile(
  "incq %0" : "+m"(sum)
);
```
也不能保证原子性,打破了一条惯例”机器每次执行一条指令“（多处理器带来的一条指令都不原子）


## sum-opt
展示执行顺序改变

添加编译优化后的sum代码会有不一样的效果：
`-o1`的结果是10000， `-o2`的结果是20000；所以编译器到底做了什么样的优化？

编译器只能在假设程序是单线程才能做优化，要么就什么都不能优化了。

## store-load 
展示线程间内存的可见性

处理器也类似于编译器，也会进行一些优化！内存模型的区别

# lecture06

## peterson

我们的Peterson算法的正确性是建立在一定的假设上的，所以我们直接写成c代码
```c peterson.c
#define BARRIER 
```
是不能正确工作的。

同样的，我们只加入编译器的barrier
```c peterson.c
#define BARRIER asm volatile(" " :::"memory")
```
也是不能正确工作

只有
```c peterson.c
#define BARRIER asm volatile("mfence" :::"memory")
//或者
#define BARRIER __sync_synchronize()
```
才能保证不会出错

## sum-atomic


# lecture07
## sum-spinlock
自旋锁的实现

## cmpxchg
另外一个更加强大的原子指令，我们可以打印出来真值表来理解这个过程

## sum-scalability
sum的自旋锁的实现在随着线程数量增多反而不好。

## sum-mutex
为了修复上面的问题，我们使用os来实现锁的管理与调度，让哪些没有获得锁的线程让出（”让出“这个操作只能由os才能实现）

# lecture08

## printf
展示gdb的一些使用的技巧

我们怎么去查看我们库函数的实现？我们可以通过配置`~/.gdbinit`来实现全局的配置
```c .gdbinit
directory /usr/src/glibc/giblc-2.35/
layout asm
set pagination off
```
当然glibc的代码就是屎山，jyy推荐看msul的实现来学习源码

## nondet
展示gdb手册上的reverse debug

##
展示gdb的多线程的调试

# lecture09
计算图，调度器和生产者-消费者问题

几乎所有的并行的问题都可以这么的实现和思考
{% asset_img img03.png %}

本节是同步问题的一种万能的解决办法：**条件变量**

## pc-mutex
用互斥锁实现生产者-消费者，可以看到我们用互斥锁实现的过程会有spin的过程，这会像我们不使用syscall的lock一样的问题

## pc-check
来检查上面互斥锁实现同步的打印的括号序列的正确性问题

## pc-cv
错误的生产者-消费者的条件变量的实现，错误的原因很令人警觉。

运行
```bash 
./a.out 2 2
```
才会出现问题。
解决方法是把`if`改成`while`这是一个万能的方法。
```c pc-cv.c
void Tproduce() {
  while (1) {
    mutex_lock(&lk);
    if (!CAN_PRODUCE) {
      cond_wait(&cv, &lk);
    }
    printf("("); count++;
    cond_signal(&cv); //这里不会死锁的原因是上面用的是if
    mutex_unlock(&lk);
  }
}
```
变成
```c pc-cv-while.c
void Tproduce() {
  while (1) {
    mutex_lock(&lk);
    while (!CAN_PRODUCE) {
      cond_wait(&cv, &lk);
    }
    printf("("); count++;
    cond_broadcast(&cv);
    mutex_unlock(&lk);
  }
}
```
>注意把`cond_signal`变成了`cond_broadcast`

## pc-cv-while
修复了上面问题，并且是一个解决同步问题的一个万能的办法

## fish
条件变量的应用：这已经是天花板的题目了
{% asset_img img04.png %}
把上面的状态图理解清楚并对应代码就可以了。


在思考所有的同步问题的时候，只要回到下面的思考模式就行了：只要能把条件写出来，就成功了！


```c 
WAIT_UNTIL(cond) with (mutex) {
  // cond 在此时成立
  work();
}
```
>注意上面的`WAIT_UNTIL`可以通过`wait`和`broadcast`来实现，`signal`唤起等待`cv`可能会出现死锁。例如一个consumer唤起另一个consumer而不是producer就会死锁

>注意上面的代码实际上消灭了并行，因为所有的操作都上锁了。而实际上很多任务可以在线程的本地做，就可以实现并行

# lecture10

信号量对应于**资源数量**的同步对象

优雅的实现生产者和消费者
如下图的考虑有两个信号量
{% asset_img img05.png %}

```c 
void P(sem_t *sem) { // wait
  wait_until(sem->count > 0) {
    sem->count--;
  }
}

void V(sem_t *sem) { // post (signal)
  atomic {
    sem->count++;
  }
}
// 生产者，消费者
void Tproduce() {
  P(&empty);
  printf("("); // 注意共享数据结构访问需互斥
  V(&fill);
}
void Tconsume() {
  P(&fill);
  printf(")");
  V(&empty);
}
```



## pc-sem
producer-consumer的信号量的实现


## join-sem
> 理解信号量的相比与条件变量的特别之处，和对应的两种的特别之处

信号量典型应用
1. 第一种：一次临时的happens before。
2. 第二章：实现计数型的同步

这里是模拟了join的第一种方式，main线程有顺序的等待线程的执行完毕

## fish-sem

信号量解决动态产生的动态图问题
